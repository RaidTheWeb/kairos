diff -urN --no-dereference mlibc/meson.build mlibc-nomos/meson.build
--- mlibc/meson.build	2025-12-08 14:36:43.148792477 +1300
+++ mlibc-nomos/meson.build	2025-12-08 14:39:45.624615816 +1300
@@ -263,6 +263,10 @@
 	rtld_include_dirs += include_directories('sysdeps/menix/include')
 	libc_include_dirs += include_directories('sysdeps/menix/include')
 	subdir('sysdeps/menix')
+elif host_machine.system() == 'nomos'
+        rtld_include_dirs += include_directories('sysdeps/nomos/include')
+        libc_include_dirs += include_directories('sysdeps/nomos/include')
+        subdir('sysdeps/nomos')
 # ANCHOR: demo-sysdeps
 elif host_machine.system() == 'demo'
 	subdir('sysdeps/demo')
diff -urN --no-dereference mlibc/options/ansi/generic/string.cpp mlibc-nomos/options/ansi/generic/string.cpp
--- mlibc/options/ansi/generic/string.cpp	2025-12-08 14:36:43.150242944 +1300
+++ mlibc-nomos/options/ansi/generic/string.cpp	2025-12-09 02:45:54.468440282 +1300
@@ -286,7 +286,17 @@
 }
 
 int wcscoll(const wchar_t *, const wchar_t *) { MLIBC_STUB_BODY; }
-int wcsncmp(const wchar_t *, const wchar_t *, size_t) { MLIBC_STUB_BODY; }
+int wcsncmp(const wchar_t *l, const wchar_t *r, size_t n) {
+	for(size_t i = 0; i < n; i++) {
+		if(l[i] != r[i]) {
+			return l[i] - r[i];
+		}
+		if(l[i] == 0) {
+			return 0;
+		}
+	}
+	return 0;
+}
 size_t wcsxfrm(wchar_t *__restrict, const wchar_t *__restrict, size_t) { MLIBC_STUB_BODY; }
 
 int wmemcmp(const wchar_t *a, const wchar_t *b, size_t size) {
diff -urN --no-dereference mlibc/options/posix/generic/wchar.cpp mlibc-nomos/options/posix/generic/wchar.cpp
--- mlibc/options/posix/generic/wchar.cpp	2025-12-08 14:36:43.169243296 +1300
+++ mlibc-nomos/options/posix/generic/wchar.cpp	2025-12-09 17:45:09.461269467 +1300
@@ -562,9 +562,19 @@
 	return 0;
 }
 
-int wcscasecmp(const wchar_t *, const wchar_t *) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+int wcscasecmp(const wchar_t *s1, const wchar_t *s2) {
+	size_t i = 0;
+	while(true) {
+		wint_t c1 = towlower(s1[i]);
+		wint_t c2 = towlower(s2[i]);
+		if(c1 == L'\0' && c2 == L'\0')
+			return 0;
+		if(c1 < c2)
+			return -1;
+		if(c1 > c2)
+			return 1;
+		i++;
+	}
 }
 
 size_t wcsnlen(const wchar_t *, size_t) {
diff -urN --no-dereference mlibc/sysdeps/astral/generic/generic.cpp mlibc-nomos/sysdeps/astral/generic/generic.cpp
--- mlibc/sysdeps/astral/generic/generic.cpp	2025-12-08 14:36:43.174118419 +1300
+++ mlibc-nomos/sysdeps/astral/generic/generic.cpp	2025-12-14 03:26:07.373836764 +1300
@@ -240,7 +240,7 @@
 		long ret;
 		return syscall(SYSCALL_PAUSE, &ret);
 	}
-	
+
 	int sys_chroot(const char *path) {
 		long ret;
 		return syscall(SYSCALL_CHROOT, &ret, (uint64_t)path);
@@ -288,7 +288,7 @@
 	#define TTY_NAME_MAX 32
 	#define TTY_PREFIX "/dev/"
 
-	
+
 	int sys_ttyname(int fd, char * buffer, size_t size) {
 		size_t prefixLen = strlen(TTY_PREFIX);
 		if(size < TTY_NAME_MAX + prefixLen) {
@@ -447,7 +447,7 @@
 	#ifndef MLIBC_BUILDING_RTLD
 
 	[[noreturn]] void sys_thread_exit() {
-		syscall(SYSCALL_THREADEXIT, nullptr);
+		syscall(SYSCALL_EXITTHREAD, nullptr);
 		__builtin_unreachable();
 	}
 
@@ -498,7 +498,7 @@
 		*length = ret;
 		return err;
 	}
-	
+
 	int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
 		long ret;
 		return syscall(SYSCALL_BIND, &ret, fd, (uint64_t)addr_ptr, addr_length);
@@ -690,7 +690,7 @@
 	int sys_link(const char *old_path, const char *new_path) {
 		return sys_linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);
 	}
-	
+
 	int sys_symlinkat(const char *target_path, int dirfd, const char *link_path) {
 		return dolink(AT_FDCWD, target_path, dirfd, link_path, 0, 1);
 	}
@@ -826,7 +826,7 @@
 		long ret;
 		syscall(SYSCALL_PRINT, &ret, (uint64_t)message);
 	}
-	
+
 	[[noreturn]] void sys_libc_panic() {
 		sys_libc_log("mlibc: panic");
 		sys_exit(1);
@@ -863,7 +863,7 @@
 		size += 4096 - (size % 4096);
 		return sys_vm_unmap(pointer, size);
 	}
-	
+
 	int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
 		long ret;
 		long err = syscall(SYSCALL_OPENAT, &ret, dirfd, (uint64_t)path, flags, mode);
@@ -901,7 +901,7 @@
 		*new_offset = ret;
 		return error;
 	}
-	
+
 	int sys_close(int fd) {
 		long r;
 		return syscall(SYSCALL_CLOSE, &r, fd);
@@ -918,7 +918,7 @@
 		long ret;
 		return syscall(SYSCALL_MUNMAP, &ret, (uintptr_t)pointer, size);
 	}
-	
+
 	int sys_isatty(int fd) {
 		long ret;
 		return syscall(SYSCALL_ISATTY, &ret, fd);
diff -urN --no-dereference mlibc/sysdeps/astral/threading/x86_64-thread.cpp mlibc-nomos/sysdeps/astral/threading/x86_64-thread.cpp
--- mlibc/sysdeps/astral/threading/x86_64-thread.cpp	2025-12-08 14:36:43.175074977 +1300
+++ mlibc-nomos/sysdeps/astral/threading/x86_64-thread.cpp	2025-12-11 17:04:50.130521581 +1300
@@ -39,7 +39,7 @@
 		} else {
 			*stack_base = *stack;
 		}
-		
+
 		*stack = (void *)((char *)*stack_base + *stack_size);
 
 		void **stack_it = (void **)*stack;
diff -urN --no-dereference mlibc/sysdeps/nomos/crt-x86_64/crt1.S mlibc-nomos/sysdeps/nomos/crt-x86_64/crt1.S
--- mlibc/sysdeps/nomos/crt-x86_64/crt1.S	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/crt-x86_64/crt1.S	2025-12-27 12:38:30.821255992 +1300
@@ -0,0 +1,10 @@
+
+.section .text
+.global _start
+_start:
+	mov %rsp, %rsi
+	mov $main, %rdi
+	call __mlibc_entry
+
+.section .note.GNU-stack,"",%progbits
+
diff -urN --no-dereference mlibc/sysdeps/nomos/crt-x86_64/crti.S mlibc-nomos/sysdeps/nomos/crt-x86_64/crti.S
--- mlibc/sysdeps/nomos/crt-x86_64/crti.S	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/crt-x86_64/crti.S	2025-12-11 16:03:29.061959496 +1300
@@ -0,0 +1,13 @@
+    .ident "x86_64-nomos-mlibc crti"
+    .section .init
+    .global _init
+    .type _init, @function
+_init:
+    push %rax
+
+.section .fini
+.global _fini
+.type _fini, @function
+_fini:
+    push %rax
+.section .note.GNU-stack,"",%progbits
diff -urN --no-dereference mlibc/sysdeps/nomos/crt-x86_64/crtn.S mlibc-nomos/sysdeps/nomos/crt-x86_64/crtn.S
--- mlibc/sysdeps/nomos/crt-x86_64/crtn.S	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/crt-x86_64/crtn.S	2025-12-08 15:16:19.864290226 +1300
@@ -0,0 +1,10 @@
+.ident "x86_64-nomos-mlibc crtn"
+
+.section .init
+    pop %rax
+    ret
+
+.section .fini
+    pop %rax
+    ret
+.section .note.GNU-stack,"",%progbits
diff -urN --no-dereference mlibc/sysdeps/nomos/crt-x86_64/Scrt1.S mlibc-nomos/sysdeps/nomos/crt-x86_64/Scrt1.S
--- mlibc/sysdeps/nomos/crt-x86_64/Scrt1.S	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/crt-x86_64/Scrt1.S	2025-12-08 14:38:15.127713948 +1300
@@ -0,0 +1,7 @@
+.section .text
+.global _start
+_start:
+    mov %rsp, %rsi
+    lea main(%rip), %rdi
+    call __mlibc_entry
+.section .note.GNU-stack,"",%progbits
diff -urN --no-dereference mlibc/sysdeps/nomos/generic/entry.cpp mlibc-nomos/sysdeps/nomos/generic/entry.cpp
--- mlibc/sysdeps/nomos/generic/entry.cpp	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/generic/entry.cpp	2025-12-10 19:50:59.045927715 +1300
@@ -0,0 +1,25 @@
+#include <mlibc/elf/startup.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/auxv.h>
+#include <nomos/syscall.h>
+
+extern "C" void __dlapi_enter(uintptr_t *);
+
+extern char **environ;
+
+extern "C" void __mlibc_sigret_inner(void) {
+    syscall(SYSCALL_SIGRETURN);
+    __builtin_unreachable();
+}
+
+// Userspace sigret trampoline.
+extern "C" __attribute__((naked)) void __mlibc_sigret(void) {
+    asm("call __mlibc_sigret_inner");
+}
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[]), uintptr_t *entry_stack) {
+    __dlapi_enter(entry_stack);
+    auto result = main_fn(mlibc::entry_stack.argc, mlibc::entry_stack.argv, environ);
+    exit(result);
+}
diff -urN --no-dereference mlibc/sysdeps/nomos/generic/generic.cpp mlibc-nomos/sysdeps/nomos/generic/generic.cpp
--- mlibc/sysdeps/nomos/generic/generic.cpp	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/generic/generic.cpp	2026-01-22 16:40:35.540356609 +1300
@@ -0,0 +1,1122 @@
+#include <asm/ioctls.h>
+#include <bits/ensure.h>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/debug.hpp>
+#include <mlibc/tcb.hpp>
+#include <nomos/syscall.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <abi-bits/stat.h>
+
+#define STUB { \
+    __ensure(!"STUB function was called."); \
+    __builtin_unreachable(); \
+}
+
+extern "C" void __mlibc_thread_trampoline(void *(*fn)(void *), Tcb *tcb, void *arg) {
+    if (mlibc::sys_tcb_set(tcb)) {
+        __ensure(!"failed to set tcb for new thread");
+    }
+
+    while (__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED) == 0) {
+        mlibc::sys_futex_wait(&tcb->tid, 0, nullptr);
+    }
+
+    tcb->invokeThreadFunc(reinterpret_cast<void *>(fn), arg);
+
+    __atomic_store_n(&tcb->didExit, 1, __ATOMIC_RELEASE);
+    mlibc::sys_futex_wake(&tcb->didExit);
+
+    mlibc::sys_thread_exit();
+}
+
+namespace mlibc {
+    void sys_libc_log(const char *msg) {
+        syscall(SYSCALL_DEBUG, (uint64_t)msg);
+    }
+
+    [[noreturn]] void sys_exit(int status) {
+        syscall(SYSCALL_EXIT, status);
+        __builtin_unreachable();
+    }
+
+    void sys_libc_panic(void) {
+        const char *msg = "PANIC";
+        syscall(SYSCALL_DEBUG, (uint64_t)msg);
+        sys_exit(1);
+    }
+
+    int sys_tcb_set(void *ptr) {
+        // Set FS base using PRCTL.
+        ssize_t ret = syscall(SYSCALL_PRCTL, 0x1002, (uint64_t)ptr);
+        if (ret < 0) {
+            return -ret;
+        }
+
+        return 0;
+    }
+
+    #define FUTEX_WAIT 0
+    #define FUTEX_WAKE 1
+
+    int sys_futex_wait(int *ptr, int expected, const struct timespec *time) {
+        ssize_t ret = syscall(SYSCALL_FUTEX, (uint64_t)ptr, FUTEX_WAIT, expected, (uint64_t)time);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+    int sys_futex_wake(int *ptr) {
+        ssize_t ret = syscall(SYSCALL_FUTEX, (uint64_t)ptr, FUTEX_WAKE, INT_MAX, 0);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_futex_tid(void) {
+        return syscall(SYSCALL_GETTID);
+    }
+
+    pid_t sys_getpid(void) {
+        return syscall(SYSCALL_GETPID);
+    }
+
+    pid_t sys_getppid(void) {
+        return syscall(SYSCALL_GETPPID);
+    }
+
+    pid_t sys_gettid(void) {
+        return syscall(SYSCALL_GETTID);
+    }
+
+    int sys_fork(pid_t *child) {
+        ssize_t ret = syscall(SYSCALL_FORK);
+
+        if (ret < 0) {
+            return -ret;
+        }
+
+        *child = ret;
+        return 0;
+    }
+
+    int sys_setsid(pid_t *sid) {
+        ssize_t ret = syscall(SYSCALL_SETSID);
+        if (ret < 0) {
+            return -ret;
+        }
+        *sid = ret;
+        return 0;
+    }
+
+    pid_t sys_getpgid(pid_t pid, pid_t *pgid) {
+        ssize_t ret = syscall(SYSCALL_GETPGID, pid);
+        if (ret < 0) {
+            return -ret;
+        }
+
+        *pgid = (pid_t)ret;
+        return 0;
+    }
+
+    int sys_setpgid(pid_t pid, pid_t pgid) {
+        ssize_t ret = syscall(SYSCALL_SETPGID, pid, pgid);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) {
+        uint64_t ret = syscall(SYSCALL_MMAP, (uint64_t)hint, size, prot, flags, fd, offset);
+
+        if ((ssize_t)ret < 0) {
+            return -ret; // Make errno positive.
+        }
+
+        *window = (void *)ret;
+        return 0; // Assume success.
+    }
+
+    int sys_vm_protect(void *ptr, size_t size, int prot) {
+        ssize_t ret = syscall(SYSCALL_MPROTECT, (uint64_t)ptr, size, prot);
+
+        if (ret < 0) {
+            return -ret;
+        }
+
+        return 0;
+    }
+
+    int sys_vm_unmap(void *ptr, size_t size) {
+        ssize_t ret = syscall(SYSCALL_MUNMAP, (uint64_t)ptr, size);
+
+        if (ret < 0) {
+            return -ret;
+        }
+
+        return 0;
+    }
+
+    int sys_anon_allocate(size_t size, void **ptr) {
+        return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON, 0, 0, ptr);
+    }
+
+    int sys_anon_free(void *ptr, size_t size) {
+        return sys_vm_unmap(ptr, size);
+    }
+
+    enum clockop {
+        CLOCK_GETRES = 0,
+        CLOCK_GET = 1,
+        CLOCK_SET = 2
+    };
+
+    int sys_clock_get(int clock, time_t *secs, long *nanos) {
+        struct timespec time = { 0, 0 };
+        ssize_t ret = syscall(SYSCALL_CLOCK, CLOCK_GET, clock, (uint64_t)&time);
+        if (ret < 0) {
+            return -ret;
+        }
+        *secs = time.tv_sec;
+        *nanos = time.tv_nsec;
+        return 0;
+    }
+
+    int sys_clock_getres(int clock, time_t *secs, long *nanos) {
+        struct timespec time = { 0, 0 };
+        ssize_t ret = syscall(SYSCALL_CLOCK, CLOCK_GETRES, clock, (uint64_t)&time);
+        if (ret < 0) {
+            return -ret;
+        }
+        *secs = time.tv_sec;
+        *nanos = time.tv_nsec;
+        return 0;
+    }
+
+    int sys_clock_set(int clock, time_t secs, long nanos) {
+        struct timespec time = { .tv_sec = secs, .tv_nsec = nanos };
+        ssize_t ret = syscall(SYSCALL_CLOCK, CLOCK_SET, clock, (uint64_t)&time);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_seek(int fd, off_t offset, int whence, off_t *newoff) {
+        ssize_t ret = syscall(SYSCALL_SEEK, fd, offset, whence);
+        if (ret < 0) {
+            return -ret;
+        }
+
+        *newoff = ret;
+        return 0; // Assume success.
+    }
+
+    int sys_read(int fd, void *buf, size_t count, ssize_t *read) {
+        ssize_t ret = syscall(SYSCALL_READ, fd, (uint64_t)buf, count);
+        if (ret < 0) {
+            *read = 0;
+            return -ret;
+        }
+
+        *read = ret;
+        return 0; // Assume success.
+    }
+
+    int sys_write(int fd, const void *buf, size_t count, ssize_t *written) {
+        ssize_t ret = syscall(SYSCALL_WRITE, fd, (uint64_t)buf, count);
+        if (ret < 0) {
+            *written = 0;
+            return -ret;
+        }
+
+        *written = ret;
+        return 0; // Assume success.
+    }
+
+    int sys_dup(int fd, int flags, int *newfd) {
+        ssize_t ret = syscall(SYSCALL_DUP, fd, flags);
+
+        if (ret < 0) {
+            return -ret;
+        }
+
+        *newfd = ret;
+        return 0;
+    }
+
+    int sys_dup2(int fd, int flags, int newfd) {
+        ssize_t ret = syscall(SYSCALL_DUP2, fd, flags, newfd);
+        if (ret < 0) {
+            return -ret;
+        }
+
+        return 0;
+    }
+
+    int sys_close(int fd) {
+        return syscall(SYSCALL_CLOSE, fd);
+    }
+
+    int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
+        ssize_t ret = syscall(SYSCALL_IOCTL, fd, request, (uint64_t)arg);
+        if (ret < 0) {
+            return -ret;
+        }
+
+        if (result) {
+            *result = ret;
+        }
+        return 0;
+    }
+
+    int sys_tcgetattr(int fd, struct termios *attr) {
+        int ret;
+
+        if (int e = sys_ioctl(fd, TCGETS, (void *)attr, &ret); e) {
+            return e;
+        }
+
+        return 0;
+    }
+
+    int sys_tcsetattr(int fd, int optional, const struct termios *attr) {
+        int req;
+
+        switch (optional) {
+            case TCSANOW:
+                req = TCSETS;
+                break;
+            case TCSADRAIN:
+                req = TCSETSW;
+                break;
+            case TCSAFLUSH:
+                req = TCSETSF;
+                break;
+        }
+
+        if (int e = sys_ioctl(fd, req, (void *)attr, NULL); e) {
+            return e;
+        }
+
+        return 0;
+    }
+
+    int sys_tcflush(int fd, int action) {
+        return sys_ioctl(fd, TCFLSH, &action, NULL);
+    }
+
+    int sys_tcdrain(int fd) {
+        return sys_ioctl(fd, TCSBRK, (void *)1, NULL);
+    }
+
+    int sys_tcflow(int fd, int action) {
+        return sys_ioctl(fd, TCXONC, &action, NULL);
+    }
+
+    int sys_isatty(int fd) {
+        unsigned short ws[4];
+        int result;
+        if (!sys_ioctl(fd, 0x5413, &ws, &result)) {
+            return 0;
+        }
+        return ENOTTY;
+    }
+
+#if !defined(MLIBC_BUILDING_RTLD) || defined(MLIBC_STATIC_BUILD)
+
+#define TTYNAMEMAX 32
+#define TTYPREFIX "/dev/"
+#define TTYNAMEIOCTL 0x16789123
+
+    int sys_ttyname(int fd, char *buf, size_t size) {
+        size_t len = strlen(TTYPREFIX);
+        if (size < TTYNAMEMAX + len) {
+            return ENAMETOOLONG;
+        }
+
+        int res;
+        if (int e = sys_ioctl(fd, TTYNAMEIOCTL, buf, &res); e) {
+            return e;
+        }
+        return 0;
+    }
+
+#endif
+
+    int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
+        ssize_t ret = syscall(SYSCALL_OPENAT, dirfd, (uint64_t)path, flags, mode);
+        if (ret < 0) {
+            return -ret;
+        }
+
+        *fd = ret;
+        return 0; // Assume success.
+    }
+
+    int sys_open(const char *path, int flags, mode_t mode, int *fd) {
+        return sys_openat(AT_FDCWD, path, flags, mode, fd);
+    }
+
+    int sys_open_dir(const char *path, int *handle) {
+        return sys_open(path, O_DIRECTORY, 0660, handle);
+    }
+
+
+    extern "C" void __mlibc_sigret(void);
+
+#if !defined(MLIBC_BUILDING_RTLD) || defined(MLIBC_STATIC_BUILD)
+
+    int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
+        ssize_t ret;
+        if (act) {
+            struct sigaction kact = *act;
+            // Set the restorer to our userspace trampoline.
+            kact.sa_restorer = __mlibc_sigret;
+            ret = syscall(SYSCALL_SIGACTION, signum, (uint64_t)&kact, (uint64_t)oldact);
+        } else {
+            ret = syscall(SYSCALL_SIGACTION, signum, 0, (uint64_t)oldact);
+        }
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+#endif
+
+    int sys_kill(pid_t pid, int sig) {
+        ssize_t ret = syscall(SYSCALL_KILL, pid, sig);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_sigreturn() {
+        syscall(SYSCALL_SIGRETURN);
+        __builtin_unreachable();
+    }
+
+    int sys_sigprocmask(int how, const sigset_t *set, sigset_t *retrieve) {
+        ssize_t ret = syscall(SYSCALL_SIGPROCMASK, how, (uint64_t)set, (uint64_t)retrieve);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_execve(const char *path, char *const argv[], char *const envp[]) {
+        ssize_t ret = syscall(SYSCALL_EXECVE, (uint64_t)path, (uint64_t)argv, (uint64_t)envp);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
+        ssize_t ret = syscall(SYSCALL_WAITPID, pid, (uint64_t)status, flags, (uint64_t)ru);
+        if (ret < 0) {
+            return -ret;
+        }
+
+        *ret_pid = ret;
+        return 0;
+    }
+
+    int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) {
+        ssize_t ret = syscall(SYSCALL_GETDENTS, handle, (uint64_t)buffer, max_size);
+        if (ret < 0) {
+            return -ret;
+        }
+
+        *bytes_read = ret;
+        return 0;
+    }
+
+    int sys_chdir(const char *path) {
+        ssize_t ret = syscall(SYSCALL_CHDIR, (uint64_t)path);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_fchdir(int fd) {
+        ssize_t ret = syscall(SYSCALL_FCHDIR, fd);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid) {
+        return syscall(SYSCALL_GETRESUID, (uint64_t)ruid, (uint64_t)euid, (uint64_t)suid);
+    }
+
+    int sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid) {
+        return syscall(SYSCALL_GETRESGID, (uint64_t)rgid, (uint64_t)egid, (uint64_t)sgid);
+    }
+
+    uid_t sys_getuid(void) {
+        uid_t ruid, euid, suid;
+        sys_getresuid(&ruid, &euid, &suid);
+        return ruid;
+    }
+
+    gid_t sys_getgid(void) {
+        gid_t rgid, egid, sgid;
+        sys_getresgid(&rgid, &egid, &sgid);
+        return rgid;
+    }
+
+    uid_t sys_geteuid(void) {
+        uid_t ruid, euid, suid;
+        sys_getresuid(&ruid, &euid, &suid);
+        return euid;
+    }
+
+    gid_t sys_getegid(void) {
+        gid_t rgid, egid, sgid;
+        sys_getresgid(&rgid, &egid, &sgid);
+        return egid;
+    }
+
+    int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid) {
+        ssize_t ret = syscall(SYSCALL_SETRESUID, ruid, euid, suid);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid) {
+        ssize_t ret = syscall(SYSCALL_SETRESGID, rgid, egid, sgid);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_setuid(uid_t uid) {
+        int ret = sys_setresuid(uid, uid, uid);
+        return ret;
+    }
+
+    int sys_setgid(gid_t gid) {
+        int ret = sys_setresgid(gid, gid, gid);
+        return ret;
+    }
+
+    int sys_seteuid(uid_t euid) {
+        return sys_setresuid(-1, euid, -1);
+    }
+
+    int sys_setegid(gid_t egid) {
+        return sys_setresgid(-1, egid, -1);
+    }
+
+    void sys_yield(void) {
+        syscall(SYSCALL_YIELD);
+    }
+
+    int sys_getcwd(char *buf, size_t size) {
+        ssize_t ret = syscall(SYSCALL_GETCWD, (uint64_t)buf, size);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_fcntl(int fd, int request, va_list args, int *result) {
+        ssize_t ret = syscall(SYSCALL_FCNTL, fd, request, va_arg(args, uint64_t));
+        if (ret < 0) {
+            return -ret;
+        }
+
+        if (result) {
+            *result = ret;
+        }
+        return 0;
+    }
+
+    int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
+        ssize_t ret;
+
+        switch (fsfdt) {
+            case fsfd_target::fd: {
+                ret = syscall(SYSCALL_STAT, fd, (uint64_t)"", 0, (uint64_t)statbuf, AT_EMPTY_PATH);
+                break;
+            }
+            case fsfd_target::path: {
+                ret = syscall(SYSCALL_STAT, AT_FDCWD, (uint64_t)path, strlen(path), (uint64_t)statbuf, flags);
+                break;
+            }
+            case fsfd_target::fd_path: {
+                size_t len = strlen(path);
+                ret = syscall(SYSCALL_STAT, fd, (uint64_t)path, len, (uint64_t)statbuf, flags);
+                break;
+            }
+            default: {
+                __ensure(!"stat: Invalid fsfdt");
+                __builtin_unreachable();
+            }
+        }
+
+        if (ret < 0) {
+            return -ret;
+        }
+
+        return ret;
+    }
+
+    int sys_access(const char *pathname, int mode) {
+        size_t len = strlen(pathname);
+        ssize_t ret = syscall(SYSCALL_ACCESS, AT_FDCWD, (uint64_t)pathname, len, mode, 0);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_faccessat(int fd, const char *pathname, int mode, int flags) {
+        size_t len = strlen(pathname);
+        ssize_t ret = syscall(SYSCALL_ACCESS, fd, (uint64_t)pathname, len, mode, flags);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_readlink(const char *path, void *buf, size_t size, ssize_t *length) {
+        ssize_t ret;
+        size_t path_len = strlen(path);
+        ret = syscall(SYSCALL_READLINK, AT_FDCWD, (uint64_t)path, path_len, (uint64_t)buf, size);
+        if (ret < 0) {
+            return -ret;
+        } else {
+            *length = ret;
+            return 0;
+        }
+    }
+
+    int sys_uname(struct utsname *buf) {
+        ssize_t ret = syscall(SYSCALL_UNAME, (uint64_t)buf);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_gethostname(char *name, size_t len) {
+        struct utsname uts;
+        if (int err = sys_uname(&uts); err) {
+            return err;
+        }
+        ssize_t host_len = strlen(uts.nodename);
+        if ((size_t)host_len >= len) {
+            return ENAMETOOLONG;
+        }
+        memcpy(name, uts.nodename, host_len);
+        name[host_len] = '\0';
+        return 0;
+    }
+
+    int sys_pipe(int *fd, int flags) {
+        ssize_t ret = syscall(SYSCALL_PIPE, (uint64_t)fd, flags);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_unlinkat(int fd, const char *path, int flags) {
+        size_t len = strlen(path);
+        ssize_t ret = syscall(SYSCALL_UNLINK, fd, (uint64_t)path, len, flags);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_rmdir(const char *path) {
+        size_t len = strlen(path);
+        ssize_t ret = syscall(SYSCALL_UNLINK, AT_FDCWD, (uint64_t)path, len, AT_REMOVEDIR);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
+        ssize_t ret = syscall(SYSCALL_PPOLL, (uint64_t)fds, nfds, (uint64_t)timeout, (uint64_t)sigmask);
+        if (ret < 0) {
+            return -ret;
+        }
+        if (num_events) {
+            *num_events = ret;
+        }
+        return 0;
+    }
+
+    int sys_poll(struct pollfd *fds, nfds_t nfds, int timeout, int *num_events) {
+        struct timespec ts;
+        ts.tv_sec = timeout / 1000;
+        ts.tv_nsec = (timeout % 1000) * 1000000;
+        return sys_ppoll(fds, nfds, timeout == -1 ? NULL : &ts, NULL, num_events);
+    }
+
+    int sys_pause(void) {
+        sys_ppoll(NULL, 0, NULL, NULL, NULL);
+        return EINTR;
+    }
+
+    int sys_sigsuspend(const sigset_t *mask) {
+        return sys_ppoll(NULL, 0, NULL, mask, NULL);
+    }
+#if !defined(MLIBC_BUILDING_RTLD) || defined(MLIBC_STATIC_BUILD)
+
+    int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set, fd_set *except_set, const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
+        struct pollfd *fds = (struct pollfd *)calloc(nfds, sizeof(struct pollfd));
+        if (!fds) {
+            return ENOMEM;
+        }
+
+        for (int i = 0; i < nfds; i++) {
+            struct pollfd *fd = &fds[i];
+            fd->events = 0;
+            fd->revents = 0;
+
+            if (read_set && FD_ISSET(i, read_set)) {
+                fd->events |= POLLIN;
+            }
+            if (write_set && FD_ISSET(i, write_set)) {
+                fd->events |= POLLOUT;
+            }
+            if (except_set && FD_ISSET(i, except_set)) {
+                fd->events |= POLLPRI;
+            }
+            if (!fd->events) {
+                fd->fd = -1;
+                continue;
+            }
+            fd->fd = i;
+        }
+
+        ssize_t ret = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
+        if (ret != 0) {
+            free(fds);
+            return ret;
+        }
+
+        fd_set res_read_set, res_write_set, res_except_set;
+        FD_ZERO(&res_read_set);
+        FD_ZERO(&res_write_set);
+        FD_ZERO(&res_except_set);
+
+        for (int i = 0; i < nfds; i++) {
+            struct pollfd *fd = &fds[i];
+
+            if (read_set && FD_ISSET(i, read_set) && (fd->revents & (POLLIN | POLLERR | POLLHUP)) != 0) {
+                FD_SET(i, &res_read_set);
+            }
+            if (write_set && FD_ISSET(i, write_set) && (fd->revents & (POLLOUT | POLLERR | POLLHUP)) != 0) {
+                FD_SET(i, &res_write_set);
+            }
+            if (except_set && FD_ISSET(i, except_set) && (fd->revents & POLLPRI) != 0) {
+                FD_SET(i, &res_except_set);
+            }
+        }
+
+        free(fds);
+        if (read_set) {
+            *read_set = res_read_set;
+        }
+        if (write_set) {
+            *write_set = res_write_set;
+        }
+        if (except_set) {
+            *except_set = res_except_set;
+        }
+        return 0;
+    }
+
+    extern "C" void __mlibc_thread_entry(void);
+
+    int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
+        ssize_t ret = syscall(SYSCALL_NEWTHREAD, (uintptr_t)__mlibc_thread_entry, (uint64_t)stack);
+        if (ret < 0) {
+            return -ret;
+        }
+        *tid_out = ret;
+        return 0;
+    }
+
+    #include <sys/mman.h>
+
+    int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stacksize, size_t *guardsize, void **stackbase) {
+        *guardsize = 0x1000; // 4KB guard page.
+        *stacksize = *stacksize ? *stacksize : 0x20000;
+        if (!*stack) {
+            *stackbase = mmap(NULL, *stacksize + *guardsize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
+            if (*stackbase == MAP_FAILED) {
+                return errno;
+            }
+            munmap((char *)*stackbase + *stacksize, *guardsize); // Unmap the guard page.
+        } else {
+            *stackbase = *stack;
+        }
+
+        *stack = (void *)((uintptr_t)*stackbase + *stacksize);
+        void **sp = (void **)*stack;
+
+        #if defined(__x86_64__)
+        // Align the stack to 16 bytes as required by the ABI.
+        sp = (void **)((uintptr_t)sp & ~15);
+        #endif
+
+        *(--sp) = arg;          // Argument to thread function.
+        *(--sp) = tcb;          // TCB pointer.
+        *(--sp) = entry;        // Thread entry.
+
+        *stack = (void *)sp;
+        return 0;
+    }
+#endif
+
+    void sys_thread_exit(void) {
+        syscall(SYSCALL_EXITTHREAD);
+        __builtin_unreachable();
+    }
+
+    int sys_mknodat(int dirfd, const char *path, int mode, int dev) {
+        size_t len = strlen(path);
+        ssize_t ret = syscall(SYSCALL_MKNODAT, dirfd, (uint64_t)path, len, mode, dev);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_mkfifoat(int dirfd, const char *path, mode_t mode) {
+        // Just create a FIFO node. Kernel automatically handles creating underlying pipes for FIFOs.
+        return sys_mknodat(dirfd, path, mode | S_IFIFO, 0);
+    }
+
+    int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
+        return sys_mknodat(dirfd, path, mode | S_IFDIR, 0);
+    }
+
+    int sys_mkdir(const char *path, mode_t mode) {
+        return sys_mkdirat(AT_FDCWD, path, mode);
+    }
+
+    int sys_chmod(const char *path, mode_t mode) {
+        size_t len = strlen(path);
+        ssize_t ret = syscall(SYSCALL_CHMOD, AT_FDCWD, (uint64_t)path, len, mode, 0);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_fchmodat(int fd, const char *path, mode_t mode, int flags) {
+        size_t len = strlen(path);
+        ssize_t ret = syscall(SYSCALL_CHMOD, fd, (uint64_t)path, len, mode, flags);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_fchmod(int fd, mode_t mode) {
+        ssize_t ret = syscall(SYSCALL_CHMOD, fd, (uint64_t)"", 0, mode, AT_EMPTY_PATH);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_chown(const char *path, uid_t uid, gid_t gid) {
+        size_t len = strlen(path);
+        ssize_t ret = syscall(SYSCALL_CHOWN, AT_FDCWD, (uint64_t)path, len, uid, gid, 0);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flags) {
+        size_t len = strlen(path);
+        ssize_t ret = syscall(SYSCALL_CHOWN, fd, (uint64_t)path, len, uid, gid, flags);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_fchown(int fd, uid_t uid, gid_t gid) {
+        ssize_t ret = syscall(SYSCALL_CHOWN, fd, (uint64_t)"", 0, uid, gid, AT_EMPTY_PATH);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_umask(mode_t mode, mode_t *old) {
+        ssize_t ret = syscall(SYSCALL_UMASK, mode);
+        if (ret < 0) {
+            return -ret;
+        }
+        if (old) {
+            *old = ret;
+        }
+        return 0;
+    }
+
+    int sys_sleep(time_t *secs, long *nanos) {
+        struct timespec req = { .tv_sec = *secs, .tv_nsec = *nanos };
+        struct timespec rem = { 0, 0 };
+        ssize_t ret = syscall(SYSCALL_SLEEP, (uint64_t)&req, (uint64_t)&rem);
+        if (ret < 0) {
+            return -ret;
+        }
+        *secs = rem.tv_sec;
+        *nanos = rem.tv_nsec;
+        return 0;
+    }
+
+    int sys_sethostname(const char *name, size_t len) {
+        ssize_t ret = syscall(SYSCALL_SETHOSTNAME, (uint64_t)name, len);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+#if !defined(MLIBC_BUILDING_RTLD) || defined(MLIBC_STATIC_BUILD)
+
+    #include <sys/resource.h>
+
+    int sys_getrlimit(int resource, struct rlimit *limit) {
+        switch (resource) {
+            case RLIMIT_NOFILE:
+                limit->rlim_cur = RLIM_INFINITY;
+                limit->rlim_max = RLIM_INFINITY;
+                return 0;
+            default:
+                return EINVAL;
+        }
+    }
+#endif
+
+    int sys_sigaltstack(const stack_t *ss, stack_t *oss) {
+        ssize_t ret = syscall(SYSCALL_SIGALTSTACK, (uint64_t)ss, (uint64_t)oss);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+#if !defined(MLIBC_BUILDING_RTLD) || defined(MLIBC_STATIC_BUILD)
+    #include <fcntl.h>
+    #include <sys/file.h>
+
+    int sys_flock(int fd, int operation) {
+        struct flock lock;
+        lock.l_whence = SEEK_SET;
+        lock.l_start = 0;
+        lock.l_len = 0; // Lock the whole file.
+        lock.l_pid = sys_getpid();
+
+        switch (operation & (LOCK_SH | LOCK_EX | LOCK_UN)) {
+            case LOCK_SH:
+                lock.l_type = F_RDLCK;
+                break;
+            case LOCK_EX:
+                lock.l_type = F_WRLCK;
+                break;
+            case LOCK_UN:
+                lock.l_type = F_UNLCK;
+                break;
+            default:
+                return EINVAL;
+        }
+
+        int cmd = (operation & LOCK_NB) ? F_SETLK : F_SETLKW;
+        ssize_t ret = syscall(SYSCALL_FCNTL, fd, cmd, (uint64_t)&lock);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+#endif
+
+    int sys_ftruncate(int fd, size_t length) {
+        ssize_t ret = syscall(SYSCALL_FTRUNCATE, fd, length);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    void sys_sync() {
+        syscall(SYSCALL_SYNC);
+    }
+
+    int sys_fsync(int fd) {
+        ssize_t ret = syscall(SYSCALL_FSYNC, fd, 0);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_fdatasync(int fd) {
+        ssize_t ret = syscall(SYSCALL_FSYNC, fd, 1);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_fadvise(int fd, off_t offset, off_t len, int advice) {
+        (void)fd;
+        (void)offset;
+        (void)len;
+        (void)advice;
+        return 0;
+    }
+
+    int sys_sigpending(sigset_t *set) {
+        ssize_t ret = syscall(SYSCALL_SIGPENDING, (uint64_t)set);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_getitimer(int which, struct itimerval *value) {
+        ssize_t ret = syscall(SYSCALL_GETITIMER, which, (uint64_t)value);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value) {
+        ssize_t ret = syscall(SYSCALL_SETITIMER, which, (uint64_t)new_value, (uint64_t)old_value);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_msync(void *addr, size_t length, int flags) {
+        ssize_t ret = syscall(SYSCALL_MSYNC, (uint64_t)addr, length, flags);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_rename(const char *path, const char *newpath) {
+        size_t oldlen = strlen(path);
+        size_t newlen = strlen(newpath);
+        ssize_t ret = syscall(SYSCALL_RENAME, AT_FDCWD, (uint64_t)path, oldlen, AT_FDCWD, (uint64_t)newpath, newlen);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_renameat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath) {
+        size_t oldlen = strlen(oldpath);
+        size_t newlen = strlen(newpath);
+        ssize_t ret = syscall(SYSCALL_RENAME, olddirfd, (uint64_t)oldpath, oldlen, newdirfd, (uint64_t)newpath, newlen);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_symlinkat(const char *target, int dirfd, const char *link) {
+        size_t targetlen = strlen(target);
+        size_t linklen = strlen(link);
+        ssize_t ret = syscall(SYSCALL_SYMLINK, dirfd, (uint64_t)target, targetlen, (uint64_t)link, linklen);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_symlink(const char *target, const char *linkpath) {
+        return sys_symlinkat(target, AT_FDCWD, linkpath);
+    }
+
+    int sys_brk(void **out) {
+        (void)out;
+        return -1; // Not supported, but avoids mlibc errors.
+    }
+
+#if !defined(MLIBC_BUILDING_RTLD) || defined(MLIBC_STATIC_BUILD)
+
+    // XXX: This sucks. Why doesn't mlibc let me use getrandom() to pass in my random flags.
+    // This system call is getrandom() with blocking behavior only.
+    int sys_getentropy(void *buffer, size_t length) {
+        ssize_t ret = syscall(SYSCALL_GETRANDOM, (uint64_t)buffer, length, 0x02); // GRND_RANDOM
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+#endif
+
+    int sys_chroot(const char *path) {
+        size_t len = strlen(path);
+        ssize_t ret = syscall(SYSCALL_CHROOT, (uint64_t)path, len);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_getrusage(int scope, struct rusage *usage) {
+        ssize_t ret = syscall(SYSCALL_GETRUSAGE, scope, (uint64_t)usage);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_mount(const char *__source, const char *__target, const char *__filesystemtype, unsigned long __mountflags, const void *__data) {
+        ssize_t ret = syscall(SYSCALL_MOUNT, (uint64_t)__source, (uint64_t)__target, (uint64_t)__filesystemtype, __mountflags, (uint64_t)__data);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_umount2(const char *__target, int __flags) {
+        ssize_t ret = syscall(SYSCALL_UMOUNT, (uint64_t)__target, __flags);
+        if (ret < 0) {
+            return -ret;
+        }
+        return 0;
+    }
+
+    int sys_reboot(int arg) {
+        return ENOSYS;
+    }
+}
\ No newline at end of file
diff -urN --no-dereference mlibc/sysdeps/nomos/generic/thread.S mlibc-nomos/sysdeps/nomos/generic/thread.S
--- mlibc/sysdeps/nomos/generic/thread.S	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/generic/thread.S	2025-12-11 06:24:56.516962015 +1300
@@ -0,0 +1,9 @@
+.section .text
+.global __mlibc_thread_entry
+__mlibc_thread_entry:
+    pop %rdi # Pop thread entry function.
+    pop %rsi # Pop TCB pointer.
+    pop %rdx # Pop argument to thread entry function.
+    call __mlibc_thread_trampoline
+
+.section .note.GNU-stack,"",%progbits
\ No newline at end of file
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/access.h mlibc-nomos/sysdeps/nomos/include/abi-bits/access.h
--- mlibc/sysdeps/nomos/include/abi-bits/access.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/access.h	2025-12-08 15:37:43.639166248 +1300
@@ -0,0 +1,9 @@
+#ifndef _ABIBITS_ACCESS_H
+#define _ABIBITS_ACCESS_H
+
+#define F_OK 0
+#define X_OK 1
+#define W_OK 2
+#define R_OK 4
+
+#endif /* _ABIBITS_ACCESS_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/auxv.h mlibc-nomos/sysdeps/nomos/include/abi-bits/auxv.h
--- mlibc/sysdeps/nomos/include/abi-bits/auxv.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/auxv.h	2025-12-08 15:37:43.639205009 +1300
@@ -0,0 +1,16 @@
+#ifndef _ABIBITS_AUXV_H
+#define _ABIBITS_AUXV_H
+
+#define AT_PLATFORM 15
+#define AT_HWCAP 16
+#define AT_CLKTCK 17
+#define AT_FPUCW 18
+#define AT_SECURE 23
+#define AT_RANDOM 25
+#define AT_HWCAP2 26
+#define AT_HWCAP3 29
+#define AT_HWCAP4 30
+#define AT_EXECFN 31
+#define AT_SYSINFO_EHDR 33
+
+#endif /* _ABIBITS_AUXV_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/blkcnt_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/blkcnt_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/blkcnt_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/blkcnt_t.h	2025-12-08 15:37:43.639234739 +1300
@@ -0,0 +1,8 @@
+#ifndef _ABIBITS_BLKCNT_T_H
+#define _ABIBITS_BLKCNT_T_H
+
+#include <bits/types.h>
+
+typedef __mlibc_int64 blkcnt_t;
+
+#endif /* _ABIBITS_BLKCNT_T_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/blksize_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/blksize_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/blksize_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/blksize_t.h	2025-12-08 15:37:43.639263980 +1300
@@ -0,0 +1,12 @@
+
+#ifndef _ABIBITS_BLKSIZE_T_H
+#define _ABIBITS_BLKSIZE_T_H
+
+#if defined(__x86_64__) || defined(__i386__) || defined(__m68k__)
+typedef long blksize_t;
+#elif defined(__riscv) || defined(__aarch64__) || defined(__loongarch64)
+typedef int blksize_t;
+#endif
+
+#endif /* _ABIBITS_BLKSIZE_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/clockid_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/clockid_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/clockid_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/clockid_t.h	2025-12-08 15:37:43.639297450 +1300
@@ -0,0 +1,7 @@
+#ifndef _ABIBITS_CLOCKID_T_H
+#define _ABIBITS_CLOCKID_T_H
+
+typedef int clockid_t;
+
+#endif /* _ABIBITS_CLOCKID_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/dev_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/dev_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/dev_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/dev_t.h	2025-12-08 15:37:43.639326271 +1300
@@ -0,0 +1,10 @@
+
+#ifndef _ABIBITS_DEV_T_H
+#define _ABIBITS_DEV_T_H
+
+#include <bits/types.h>
+
+typedef __mlibc_uint64 dev_t;
+
+#endif /* _ABIBITS_DEV_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/epoll.h mlibc-nomos/sysdeps/nomos/include/abi-bits/epoll.h
--- mlibc/sysdeps/nomos/include/abi-bits/epoll.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/epoll.h	2025-12-08 15:37:43.639356361 +1300
@@ -0,0 +1,12 @@
+#ifndef _ABIBITS_EPOLL_H
+#define _ABIBITS_EPOLL_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "<sys/epoll.h> is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+#define EPOLL_CLOEXEC 02000000 /* Same as __MLIBC_O_CLOEXEC */
+
+#endif /* _ABIBITS_EPOLL_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/errno.h mlibc-nomos/sysdeps/nomos/include/abi-bits/errno.h
--- mlibc/sysdeps/nomos/include/abi-bits/errno.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/errno.h	2025-12-08 15:37:43.639384512 +1300
@@ -0,0 +1,143 @@
+#ifndef _ABIBITS_ERRNO_H
+#define _ABIBITS_ERRNO_H
+
+#define EPERM            1
+#define ENOENT           2
+#define ESRCH            3
+#define EINTR            4
+#define EIO              5
+#define ENXIO            6
+#define E2BIG            7
+#define ENOEXEC          8
+#define EBADF            9
+#define ECHILD          10
+#define EAGAIN          11
+#define ENOMEM          12
+#define EACCES          13
+#define EFAULT          14
+#define ENOTBLK         15
+#define EBUSY           16
+#define EEXIST          17
+#define EXDEV           18
+#define ENODEV          19
+#define ENOTDIR         20
+#define EISDIR          21
+#define EINVAL          22
+#define ENFILE          23
+#define EMFILE          24
+#define ENOTTY          25
+#define ETXTBSY         26
+#define EFBIG           27
+#define ENOSPC          28
+#define ESPIPE          29
+#define EROFS           30
+#define EMLINK          31
+#define EPIPE           32
+#define EDOM            33
+#define ERANGE          34
+#define EDEADLK         35
+#define ENAMETOOLONG    36
+#define ENOLCK          37
+#define ENOSYS          38
+#define ENOTEMPTY       39
+#define ELOOP           40
+#define EWOULDBLOCK     EAGAIN
+#define ENOMSG          42
+#define EIDRM           43
+#define ECHRNG          44
+#define EL2NSYNC        45
+#define EL3HLT          46
+#define EL3RST          47
+#define ELNRNG          48
+#define EUNATCH         49
+#define ENOCSI          50
+#define EL2HLT          51
+#define EBADE           52
+#define EBADR           53
+#define EXFULL          54
+#define ENOANO          55
+#define EBADRQC         56
+#define EBADSLT         57
+#define EDEADLOCK       EDEADLK
+#define EBFONT          59
+#define ENOSTR          60
+#define ENODATA         61
+#define ETIME           62
+#define ENOSR           63
+#define ENONET          64
+#define ENOPKG          65
+#define EREMOTE         66
+#define ENOLINK         67
+#define EADV            68
+#define ESRMNT          69
+#define ECOMM           70
+#define EPROTO          71
+#define EMULTIHOP       72
+#define EDOTDOT         73
+#define EBADMSG         74
+#define EOVERFLOW       75
+#define ENOTUNIQ        76
+#define EBADFD          77
+#define EREMCHG         78
+#define ELIBACC         79
+#define ELIBBAD         80
+#define ELIBSCN         81
+#define ELIBMAX         82
+#define ELIBEXEC        83
+#define EILSEQ          84
+#define ERESTART        85
+#define ESTRPIPE        86
+#define EUSERS          87
+#define ENOTSOCK        88
+#define EDESTADDRREQ    89
+#define EMSGSIZE        90
+#define EPROTOTYPE      91
+#define ENOPROTOOPT     92
+#define EPROTONOSUPPORT 93
+#define ESOCKTNOSUPPORT 94
+#define EOPNOTSUPP      95
+#define ENOTSUP         EOPNOTSUPP
+#define EPFNOSUPPORT    96
+#define EAFNOSUPPORT    97
+#define EADDRINUSE      98
+#define EADDRNOTAVAIL   99
+#define ENETDOWN        100
+#define ENETUNREACH     101
+#define ENETRESET       102
+#define ECONNABORTED    103
+#define ECONNRESET      104
+#define ENOBUFS         105
+#define EISCONN         106
+#define ENOTCONN        107
+#define ESHUTDOWN       108
+#define ETOOMANYREFS    109
+#define ETIMEDOUT       110
+#define ECONNREFUSED    111
+#define EHOSTDOWN       112
+#define EHOSTUNREACH    113
+#define EALREADY        114
+#define EINPROGRESS     115
+#define ESTALE          116
+#define EUCLEAN         117
+#define ENOTNAM         118
+#define ENAVAIL         119
+#define EISNAM          120
+#define EREMOTEIO       121
+#define EDQUOT          122
+#define ENOMEDIUM       123
+#define EMEDIUMTYPE     124
+#define ECANCELED       125
+#define ENOKEY          126
+#define EKEYEXPIRED     127
+#define EKEYREVOKED     128
+#define EKEYREJECTED    129
+#define EOWNERDEAD      130
+#define ENOTRECOVERABLE 131
+#define ERFKILL         132
+#define EHWPOISON       133
+
+
+/* This is mlibc-specific. */
+#define EIEIO           4095
+
+#endif /* _ABIBITS_ERRNO_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/fcntl.h mlibc-nomos/sysdeps/nomos/include/abi-bits/fcntl.h
--- mlibc/sysdeps/nomos/include/abi-bits/fcntl.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/fcntl.h	2025-12-08 15:37:43.639412232 +1300
@@ -0,0 +1,167 @@
+#ifndef _ABIBITS_FCNTL_H
+#define _ABIBITS_FCNTL_H
+
+#include <mlibc-config.h>
+#include <abi-bits/pid_t.h>
+
+#define O_PATH 010000000
+
+#define O_ACCMODE (03 | O_PATH)
+#define O_RDONLY   00
+#define O_WRONLY   01
+#define O_RDWR     02
+
+#define O_CREAT         0100
+#define O_EXCL          0200
+#define O_NOCTTY        0400
+#define O_TRUNC        01000
+#define O_APPEND       02000
+#define O_NONBLOCK     04000
+#define O_DSYNC       010000
+#define O_ASYNC       020000
+#define O_CLOEXEC   02000000
+#define O_SYNC      04010000
+#define O_RSYNC     04010000
+#define O_NOATIME   01000000
+
+#if defined(__x86_64__) || defined(__i386__) || defined(__riscv) || defined(__loongarch64)
+#define O_DIRECT      040000
+#define O_LARGEFILE  0100000
+#define O_DIRECTORY  0200000
+#define O_NOFOLLOW   0400000
+#elif defined(__aarch64__) || defined(__m68k__)
+#define O_DIRECTORY   040000
+#define O_NOFOLLOW   0100000
+#define O_DIRECT     0200000
+#define O_LARGEFILE  0400000
+#else
+#warning "Missing <fcntl.h> support for this architecture!"
+#endif
+
+#define O_TMPFILE (020000000 | O_DIRECTORY)
+
+#define O_EXEC O_PATH
+#define O_SEARCH O_PATH
+#define O_TTY_INIT 0
+
+#define F_DUPFD  0
+#define F_GETFD  1
+#define F_SETFD  2
+#define F_GETFL  3
+#define F_SETFL  4
+
+#define F_SETOWN 8
+#define F_GETOWN 9
+#define F_SETSIG 10
+#define F_GETSIG 11
+
+#if __INTPTR_WIDTH__ == 64
+
+#define F_GETLK64 5
+#define F_SETLK64 6
+#define F_SETLKW64 7
+
+#else /* __INTPTR_WIDTH__ == 64 */
+
+#define F_GETLK64 12
+#define F_SETLK64 13
+#define F_SETLKW64 14
+
+#endif
+
+#define F_GETLK F_GETLK64
+#define F_SETLK F_SETLK64
+#define F_SETLKW F_SETLKW64
+
+#define F_SETOWN_EX 15
+#define F_GETOWN_EX 16
+
+#define F_GETOWNER_UIDS 17
+
+#define F_SETLEASE 1024
+#define F_GETLEASE 1025
+#define F_NOTIFY 1026
+#define F_DUPFD_CLOEXEC 1030
+#define F_SETPIPE_SZ 1031
+#define F_GETPIPE_SZ 1032
+#define F_ADD_SEALS 1033
+#define F_GET_SEALS 1034
+
+#define F_SEAL_SEAL 0x0001
+#define F_SEAL_SHRINK 0x0002
+#define F_SEAL_GROW 0x0004
+#define F_SEAL_WRITE 0x0008
+
+#define F_OFD_GETLK 36
+#define F_OFD_SETLK 37
+#define F_OFD_SETLKW 38
+
+#define F_RDLCK 0
+#define F_WRLCK 1
+#define F_UNLCK 2
+
+#define FD_CLOEXEC 1
+
+#define AT_FDCWD -100
+#define AT_SYMLINK_NOFOLLOW 0x100
+#define AT_REMOVEDIR 0x200
+#define AT_SYMLINK_FOLLOW 0x400
+#define AT_EACCESS 0x200
+
+#if defined(_GNU_SOURCE)
+#define AT_NO_AUTOMOUNT 0x800
+#define AT_EMPTY_PATH 0x1000
+#endif
+
+#if __MLIBC_LINUX_OPTION && defined(_GNU_SOURCE)
+
+#define DN_ACCESS 1
+#define DN_MODIFY 2
+#define DN_CREATE 4
+#define DN_DELETE 8
+#define DN_RENAME 16
+#define DN_ATTRIB 32
+#define DN_MULTISHOT 0x80000000
+
+#define AT_STATX_SYNC_AS_STAT 0x0000
+#define AT_STATX_FORCE_SYNC 0x2000
+#define AT_STATX_DONT_SYNC 0x4000
+#define AT_STATX_SYNC_TYPE 0x6000
+
+#endif /* __MLIBC_LINUX_OPTION && defined(_GNU_SOURCE) */
+
+#if defined(_GNU_SOURCE) || __MLIBC_POSIX2024
+struct f_owner_ex {
+	int type;
+	pid_t pid;
+};
+#endif /* defined(_GNU_SOURCE) || __MLIBC_POSIX2024 */
+
+#define F_OWNER_TID 0
+#define F_OWNER_PID 1
+#define F_OWNER_PGRP 2
+
+#define POSIX_FADV_NORMAL 0
+#define POSIX_FADV_RANDOM 1
+#define POSIX_FADV_SEQUENTIAL 2
+#define POSIX_FADV_WILLNEED 3
+#define POSIX_FADV_DONTNEED 4
+#define POSIX_FADV_NOREUSE 5
+
+#define S_IRWXU 0700
+#define S_IRUSR 0400
+#define S_IWUSR 0200
+#define S_IXUSR 0100
+#define S_IRWXG 070
+#define S_IRGRP 040
+#define S_IWGRP 020
+#define S_IXGRP 010
+#define S_IRWXO 07
+#define S_IROTH 04
+#define S_IWOTH 02
+#define S_IXOTH 01
+#define S_ISUID 04000
+#define S_ISGID 02000
+#define S_ISVTX 01000
+
+#endif /* _ABIBITS_FCNTL_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/fd_set.h mlibc-nomos/sysdeps/nomos/include/abi-bits/fd_set.h
--- mlibc/sysdeps/nomos/include/abi-bits/fd_set.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/fd_set.h	2025-12-08 15:37:43.639439803 +1300
@@ -0,0 +1,12 @@
+#ifndef _ABIBITS_FD_SET_H
+#define _ABIBITS_FD_SET_H
+
+#include <bits/types.h>
+
+#define FD_SETSIZE 1024
+
+typedef struct __attribute__((__aligned__(__alignof__(long)))) {
+	__mlibc_uint8 fds_bits[128];
+} fd_set;
+
+#endif /* _ABIBITS_FD_SET_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/fsblkcnt_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/fsblkcnt_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/fsblkcnt_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/fsblkcnt_t.h	2025-12-08 15:37:43.639467863 +1300
@@ -0,0 +1,8 @@
+#ifndef _ABIBITS_FSBLKCNT_T_H
+#define _ABIBITS_FSBLKCNT_T_H
+
+#include <bits/types.h>
+
+typedef __mlibc_uint64 fsblkcnt_t;
+
+#endif /* _ABIBITS_FSBLKCNT_T_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/fsfilcnt_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/fsfilcnt_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/fsfilcnt_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/fsfilcnt_t.h	2025-12-08 15:37:43.639496094 +1300
@@ -0,0 +1,8 @@
+#ifndef _ABIBITS_FSFILCNT_T_H
+#define _ABIBITS_FSFILCNT_T_H
+
+#include <bits/types.h>
+
+typedef __mlibc_uint64 fsfilcnt_t;
+
+#endif /* _ABIBITS_FSFILCNT_T_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/gid_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/gid_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/gid_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/gid_t.h	2025-12-08 15:37:43.639523534 +1300
@@ -0,0 +1,8 @@
+
+#ifndef _ABIBITS_GID_T_H
+#define _ABIBITS_GID_T_H
+
+typedef unsigned int gid_t;
+
+#endif /* _ABIBITS_GID_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/in.h mlibc-nomos/sysdeps/nomos/include/abi-bits/in.h
--- mlibc/sysdeps/nomos/include/abi-bits/in.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/in.h	2025-12-08 15:37:43.639554465 +1300
@@ -0,0 +1,245 @@
+#ifndef _ABIBITS_IN_H
+#define _ABIBITS_IN_H
+
+#include <mlibc-config.h>
+#include <abi-bits/sa_family_t.h>
+#include <abi-bits/sockaddr_storage.h>
+#include <bits/posix/in_addr_t.h>
+#include <bits/posix/in_port_t.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct in_addr {
+	in_addr_t s_addr;
+};
+
+struct sockaddr_in {
+	sa_family_t sin_family;
+	in_port_t sin_port;
+	struct in_addr sin_addr;
+	uint8_t sin_zero[8];
+};
+
+#if !__MLIBC_LINUX_OPTION || (!defined(_UAPI_LINUX_IN6_H) && !defined(_UAPI_IPV6_H))
+struct in6_addr {
+	union {
+		uint8_t __s6_addr[16];
+		uint16_t __s6_addr16[8];
+		uint32_t __s6_addr32[4];
+	} __in6_union;
+};
+#define s6_addr __in6_union.__s6_addr
+#define s6_addr16 __in6_union.__s6_addr16
+#define s6_addr32 __in6_union.__s6_addr32
+
+struct sockaddr_in6 {
+	sa_family_t     sin6_family;
+	in_port_t       sin6_port;
+	uint32_t        sin6_flowinfo;
+	struct in6_addr sin6_addr;
+	uint32_t        sin6_scope_id;
+};
+
+struct ipv6_mreq {
+	struct in6_addr ipv6mr_multiaddr;
+	unsigned        ipv6mr_interface;
+};
+
+#if defined(_GNU_SOURCE)
+struct in6_pktinfo {
+	struct in6_addr ipi6_addr;
+	uint32_t ipi6_ifindex;
+};
+#endif /* defined(_GNU_SOURCE) */
+
+#endif /* !__MLIBC_LINUX_OPTION || (!defined(_UAPI_LINUX_IN6_H) && !defined(_UAPI_IPV6_H)) */
+
+#if defined(_DEFAULT_SOURCE)
+struct ip_mreq {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_interface;
+};
+
+struct ip_mreq_source {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_interface;
+	struct in_addr imr_sourceaddr;
+};
+
+struct ip_mreqn {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_address;
+	int imr_ifindex;
+};
+
+struct in_pktinfo {
+	int ipi_ifindex;
+	struct in_addr ipi_spec_dst;
+	struct in_addr ipi_addr;
+};
+
+struct group_req {
+	uint32_t gr_interface;
+	struct sockaddr_storage gr_group;
+};
+
+struct group_source_req {
+	uint32_t gsr_interface;
+	struct sockaddr_storage gsr_group;
+	struct sockaddr_storage gsr_source;
+};
+
+#endif /* defined(_DEFAULT_SOURCE) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#define INADDR_ANY        ((in_addr_t) 0x00000000)
+#define INADDR_BROADCAST  ((in_addr_t) 0xffffffff)
+#define INADDR_NONE       ((in_addr_t) 0xffffffff)
+#define INADDR_LOOPBACK   ((in_addr_t) 0x7f000001)
+
+#define INADDR_UNSPEC_GROUP     ((in_addr_t) 0xe0000000)
+#define INADDR_ALLHOSTS_GROUP   ((in_addr_t) 0xe0000001)
+#define INADDR_ALLRTRS_GROUP    ((in_addr_t) 0xe0000002)
+#define INADDR_ALLSNOOPERS_GROUP ((in_addr_t) 0xe000006a)
+#define INADDR_MAX_LOCAL_GROUP  ((in_addr_t) 0xe00000ff)
+
+#define IN6ADDR_ANY_INIT      { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
+#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }
+
+#define INET_ADDRSTRLEN  16
+#define INET6_ADDRSTRLEN 46
+
+#define IPPORT_RESERVED 1024
+
+#define IPPROTO_IP       0
+#define IPPROTO_HOPOPTS  0
+#define IPPROTO_ICMP     1
+#define IPPROTO_IGMP     2
+#define IPPROTO_IPIP     4
+#define IPPROTO_TCP      6
+#define IPPROTO_EGP      8
+#define IPPROTO_PUP      12
+#define IPPROTO_UDP      17
+#define IPPROTO_IDP      22
+#define IPPROTO_TP       29
+#define IPPROTO_DCCP     33
+#define IPPROTO_IPV6     41
+#define IPPROTO_ROUTING  43
+#define IPPROTO_FRAGMENT 44
+#define IPPROTO_RSVP     46
+#define IPPROTO_GRE      47
+#define IPPROTO_ESP      50
+#define IPPROTO_AH       51
+#define IPPROTO_ICMPV6   58
+#define IPPROTO_NONE     59
+#define IPPROTO_DSTOPTS  60
+#define IPPROTO_MTP      92
+#define IPPROTO_BEETPH   94
+#define IPPROTO_ENCAP    98
+#define IPPROTO_PIM      103
+#define IPPROTO_COMP     108
+#define IPPROTO_SCTP     132
+#define IPPROTO_MH       135
+#define IPPROTO_UDPLITE  136
+#define IPPROTO_MPLS     137
+#define IPPROTO_RAW      255
+#define IPPROTO_MAX      256
+
+#define IP_TOS 1
+#define IP_TTL 2
+#define IP_HDRINCL 3
+#define IP_OPTIONS 4
+#define IP_RECVOPTS 6
+#define IP_RETOPTS 7
+#define IP_PKTINFO 8
+#define IP_PKTOPTIONS 9
+#define IP_MTU_DISCOVER 10
+#define IP_RECVERR 11
+#define IP_RECVTTL 12
+#define IP_MTU 14
+#define IP_MULTICAST_IF 32
+#define IP_MULTICAST_TTL 33
+#define IP_MULTICAST_LOOP 34
+#define IP_ADD_MEMBERSHIP 35
+#define IP_DROP_MEMBERSHIP 36
+#define IP_UNBLOCK_SOURCE 37
+#define IP_BLOCK_SOURCE 38
+#define IP_ADD_SOURCE_MEMBERSHIP 39
+#define IP_DROP_SOURCE_MEMBERSHIP 40
+
+#if defined(_DEFAULT_SOURCE)
+#define IP_UNICAST_IF 50
+#endif /* defined(_DEFAULT_SOURCE) */
+
+#define IPV6_2292PKTOPTIONS 6
+#define IPV6_2292HOPLIMIT 8
+#define IPV6_UNICAST_HOPS 16
+#define IPV6_MULTICAST_IF 17
+#define IPV6_MULTICAST_HOPS 18
+#define IPV6_MULTICAST_LOOP 19
+#define IPV6_JOIN_GROUP 20
+#define IPV6_LEAVE_GROUP 21
+#define IPV6_MTU_DISCOVER 23
+#define IPV6_MTU 24
+#define IPV6_RECVERR 25
+#define IPV6_V6ONLY 26
+#define IPV6_RECVPKTINFO 49
+#define IPV6_PKTINFO 50
+#define IPV6_RECVHOPLIMIT 51
+#define IPV6_HOPLIMIT 52
+
+#define IPV6_RECVTCLASS	66
+#define IPV6_TCLASS 67
+
+#define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
+
+#define IPV6_PMTUDISC_DONT 0
+#define IPV6_PMTUDISC_WANT 1
+#define IPV6_PMTUDISC_DO 2
+#define IPV6_PMTUDISC_PROBE 3
+#define IPV6_PMTUDISC_INTERFACE 4
+#define IPV6_PMTUDISC_OMIT 5
+
+#define IP_PMTUDISC_DONT 0
+#define IP_PMTUDISC_WANT 1
+#define IP_PMTUDISC_DO 2
+#define IP_PMTUDISC_PROBE 3
+#define IP_PMTUDISC_INTERFACE 4
+#define IP_PMTUDISC_OMIT 5
+
+#if defined(_DEFAULT_SOURCE)
+#define MCAST_JOIN_GROUP 42
+#define MCAST_BLOCK_SOURCE 43
+#define MCAST_UNBLOCK_SOURCE 44
+#define MCAST_JOIN_SOURCE_GROUP 46
+#define MCAST_LEAVE_SOURCE_GROUP 47
+#endif /* defined(_DEFAULT_SOURCE) */
+
+#if __MLIBC_LINUX_OPTION
+
+#define __UAPI_DEF_IN_ADDR 0
+#define __UAPI_DEF_IN_CLASS 0
+#define __UAPI_DEF_IN_IPPROTO 0
+#define __UAPI_DEF_IN_PKTINFO 0
+#define __UAPI_DEF_IP_MREQ 0
+#define __UAPI_DEF_SOCKADDR_IN 0
+
+#define __UAPI_DEF_IN6_ADDR 0
+#define __UAPI_DEF_IN6_ADDR_ALT 1
+#define __UAPI_DEF_IN6_PKTINFO 0
+#define __UAPI_DEF_IP6_MTUINFO 0
+#define __UAPI_DEF_IPPROTO_V6 0
+#define __UAPI_DEF_IPV6_MREQ 0
+#define __UAPI_DEF_IPV6_OPTIONS 0
+#define __UAPI_DEF_SOCKADDR_IN6 0
+
+#endif /* __MLIBC_LINUX_OPTION */
+
+#endif /* _ABITBITS_IN_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/ino_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/ino_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/ino_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/ino_t.h	2025-12-08 15:37:43.639586455 +1300
@@ -0,0 +1,11 @@
+
+#ifndef _ABIBITS_INO_T_H
+#define _ABIBITS_INO_T_H
+
+#include <bits/types.h>
+
+typedef __mlibc_uint64 ino_t;
+typedef ino_t ino64_t;
+
+#endif /* _ABIBITS_INO_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/inotify.h mlibc-nomos/sysdeps/nomos/include/abi-bits/inotify.h
--- mlibc/sysdeps/nomos/include/abi-bits/inotify.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/inotify.h	2025-12-08 15:37:43.639622656 +1300
@@ -0,0 +1,15 @@
+#ifndef _ABIBITS_INOTIFY_H
+#define _ABIBITS_INOTIFY_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "<sys/inotify.h> is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+#include <abi-bits/fcntl.h>
+
+#define IN_CLOEXEC O_CLOEXEC
+#define IN_NONBLOCK O_NONBLOCK
+
+#endif /* _ABIBITS_INOTIFY_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/ioctls.h mlibc-nomos/sysdeps/nomos/include/abi-bits/ioctls.h
--- mlibc/sysdeps/nomos/include/abi-bits/ioctls.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/ioctls.h	2025-12-29 16:49:28.629021837 +1300
@@ -0,0 +1,20 @@
+#ifndef _ABIBITS_IOCTLS_H
+#define _ABIBITS_IOCTLS_H
+
+#define TIOCEXCL 0x540C
+#define TIOCNXCL 0x540D
+
+#define SIOCPROTOPRIVATE 0x89E0
+#define SIOCGSTAMP 0x8906
+#define SIOCGIFNAME 0x8910
+#define SIOCGIFCONF 0x8912
+#define SIOCGIFFLAGS 0x8913
+#define SIOCSIFFLAGS 0x8914
+#define SIOCGIFADDR 0x8915
+#define SIOCGIFINDEX 0x8933
+#define SIOCATMARK 0x8905
+#define SIOCGIFHWADDR 0x8927
+#define SIOCGIFBRDADDR 0x8919
+#define SIOCGIFNETMASK 0x891B
+
+#endif /* _ABIBITS_IOCTLS_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/ipc.h mlibc-nomos/sysdeps/nomos/include/abi-bits/ipc.h
--- mlibc/sysdeps/nomos/include/abi-bits/ipc.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/ipc.h	2025-12-08 15:37:43.639681477 +1300
@@ -0,0 +1,50 @@
+#ifndef _ABIBITS_IPC_H
+#define _ABIBITS_IPC_H
+
+#include <abi-bits/uid_t.h>
+#include <abi-bits/gid_t.h>
+#include <abi-bits/mode_t.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IPC_CREAT 01000
+#define IPC_EXCL 02000
+#define IPC_NOWAIT 04000
+
+#define IPC_RMID 0
+#define IPC_SET 1
+#define IPC_STAT 2
+#define IPC_INFO 3
+
+#define IPC_PRIVATE ((key_t) 0)
+
+#if defined(__aarch64__) || defined(__i386__) || defined(__m68k__)
+#define IPC_64 0x100
+#elif defined(__x86_64__) || (defined(__riscv) && __riscv_xlen == 64) || defined(__loongarch64)
+#define IPC_64 0
+#else
+#error "Unsupported arch!"
+#endif
+
+typedef int key_t;
+
+struct ipc64_perm {
+	key_t __ipc_perm_key;
+	uid_t uid;
+	gid_t gid;
+	uid_t cuid;
+	gid_t cgid;
+	mode_t mode;
+	int __ipc_perm_seq;
+	long __unused[2];
+};
+
+#define ipc_perm ipc64_perm
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/limits.h mlibc-nomos/sysdeps/nomos/include/abi-bits/limits.h
--- mlibc/sysdeps/nomos/include/abi-bits/limits.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/limits.h	2025-12-08 15:37:43.639710698 +1300
@@ -0,0 +1,10 @@
+#ifndef _ABIBITS_LIMITS_H
+#define _ABIBITS_LIMITS_H
+
+#define __MLIBC_IOV_MAX 1024
+#define __MLIBC_LOGIN_NAME_MAX 256
+#define __MLIBC_HOST_NAME_MAX 64
+#define __MLIBC_NAME_MAX 255
+#define __MLIBC_OPEN_MAX 256
+
+#endif /*_ABIBITS_LIMITS_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/mode_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/mode_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/mode_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/mode_t.h	2025-12-08 15:37:43.639739278 +1300
@@ -0,0 +1,8 @@
+
+#ifndef _ABIBITS_MODE_T_H
+#define _ABIBITS_MODE_T_H
+
+typedef unsigned int mode_t;
+
+#endif /* _ABIBITS_MODE_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/mqueue.h mlibc-nomos/sysdeps/nomos/include/abi-bits/mqueue.h
--- mlibc/sysdeps/nomos/include/abi-bits/mqueue.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/mqueue.h	2025-12-08 15:37:43.639766869 +1300
@@ -0,0 +1,21 @@
+#ifndef _ABIBITS_MQUEUE_H
+#define _ABIBITS_MQUEUE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct mq_attr {
+	long mq_flags;
+	long mq_maxmsg;
+	long mq_msgsize;
+	long mq_curmsgs;
+	long __pad[4];
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_MQUEUE_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/msg.h mlibc-nomos/sysdeps/nomos/include/abi-bits/msg.h
--- mlibc/sysdeps/nomos/include/abi-bits/msg.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/msg.h	2025-12-08 15:37:43.639795169 +1300
@@ -0,0 +1,45 @@
+#ifndef _ABIBITS_MSG_H
+#define _ABIBITS_MSG_H
+
+#include <sys/ipc.h>
+#include <bits/ansi/time_t.h>
+#include <bits/types.h>
+#include <abi-bits/pid_t.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef unsigned long msglen_t;
+typedef unsigned long msgqnum_t;
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+#if (__INTPTR_WIDTH__ == 64) /* || x32 ABI */
+	time_t msg_stime;
+	time_t msg_rtime;
+	time_t msg_ctime;
+#else
+	unsigned long msg_stime;
+	unsigned long msg_stime_high;
+	unsigned long msg_rtime;
+	unsigned long msg_rtime_high;
+	unsigned long msg_ctime;
+	unsigned long msg_ctime_high;
+#endif
+	unsigned long msg_cbytes;
+	msgqnum_t msg_qnum;
+	msglen_t msg_qbytes;
+	pid_t msg_lspid;
+	pid_t msg_lrpid;
+	unsigned long __unused[2];
+};
+
+#define msqid_ds msqid64_ds
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_MSG_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/nlink_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/nlink_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/nlink_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/nlink_t.h	2025-12-08 15:37:43.639822740 +1300
@@ -0,0 +1,12 @@
+
+#ifndef _ABIBITS_NLINK_T_H
+#define _ABIBITS_NLINK_T_H
+
+#if defined(__x86_64__)
+typedef unsigned long nlink_t;
+#else
+typedef unsigned int nlink_t;
+#endif
+
+#endif /* _ABIBITS_NLINK_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/packet.h mlibc-nomos/sysdeps/nomos/include/abi-bits/packet.h
--- mlibc/sysdeps/nomos/include/abi-bits/packet.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/packet.h	2025-12-08 15:37:43.639849970 +1300
@@ -0,0 +1,6 @@
+#ifndef _ABIBITS_PACKET_H
+#define _ABIBITS_PACKET_H
+
+#define PACKET_HOST 0
+
+#endif /* _ABIBITS_PACKET_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/pid_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/pid_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/pid_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/pid_t.h	2025-12-08 15:37:43.639877840 +1300
@@ -0,0 +1,8 @@
+
+#ifndef _ABIBITS_PID_T_H
+#define _ABIBITS_PID_T_H
+
+typedef int pid_t;
+
+#endif /* _ABIBITS_PID_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/poll.h mlibc-nomos/sysdeps/nomos/include/abi-bits/poll.h
--- mlibc/sysdeps/nomos/include/abi-bits/poll.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/poll.h	2025-12-08 15:37:43.639905421 +1300
@@ -0,0 +1,24 @@
+#ifndef _ABIBITS_POLL_H
+#define _ABIBITS_POLL_H
+
+#define POLLIN 0x0001
+#define POLLPRI 0x0002
+#define POLLOUT 0x0004
+#define POLLERR 0x0008
+#define POLLHUP 0x0010
+#define POLLNVAL 0x0020
+#define POLLRDNORM 0x0040
+#define POLLRDBAND 0x0080
+#define POLLRDHUP 0x2000
+
+#if defined(__x86_64__) || defined(__i386__) || defined(__aarch64__) || defined(__riscv) || defined(__loongarch64)
+#define POLLWRNORM 0x0100
+#define POLLWRBAND 0x0200
+#elif defined(__m68k__)
+#define POLLWRNORM POLLOUT
+#define POLLWRBAND 0x0100
+#else
+#warning "Missing poll.h definitions for this architecture!"
+#endif
+
+#endif /* _ABIBITS_POLL_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/ptrace.h mlibc-nomos/sysdeps/nomos/include/abi-bits/ptrace.h
--- mlibc/sysdeps/nomos/include/abi-bits/ptrace.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/ptrace.h	2025-12-08 15:37:43.639933981 +1300
@@ -0,0 +1,65 @@
+#ifndef _ABIBITS_PTRACE_H
+#define _ABIBITS_PTRACE_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "ptrace() is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+#define PTRACE_PEEKTEXT 1
+#define PTRACE_PEEKDATA 2
+#define PTRACE_PEEKUSER 3
+#define PTRACE_POKETEXT 4
+#define PTRACE_POKEDATA 5
+#define PTRACE_POKEUSER 6
+#define PTRACE_CONT 7
+#define PTRACE_KILL 8
+#define PTRACE_SINGLESTEP 9
+#define PTRACE_GETREGS 12
+#define PTRACE_SETREGS 13
+#define PTRACE_GETFPREGS 14
+#define PTRACE_SETFPREGS 15
+#define PTRACE_ATTACH 16
+#define PTRACE_DETACH 17
+#define PTRACE_GETFPXREGS 18
+#define PTRACE_SETFPXREGS 19
+#define PTRACE_SYSCALL 24
+#define PTRACE_SETOPTIONS 0x4200
+#define PTRACE_GETEVENTMSG 0x4201
+#define PTRACE_GETSIGINFO 0x4202
+#define PTRACE_SETSIGINFO 0x4203
+#define PTRACE_GETREGSET 0x4204
+#define PTRACE_SETREGSET 0x4205
+#define PTRACE_SEIZE 0x4206
+#define PTRACE_INTERRUPT 0x4207
+#define PTRACE_LISTEN 0x4208
+#define PTRACE_PEEKSIGINFO 0x4209
+#define PTRACE_GETSIGMASK 0x420A
+#define PTRACE_SETSIGMASK 0x420B
+#define PTRACE_SECCOMP_GET_FILTER 0x420C
+
+#define PTRACE_O_TRACESYSGOOD 0x00000001
+#define PTRACE_O_TRACEFORK 0x00000002
+#define PTRACE_O_TRACEVFORK 0x00000004
+#define PTRACE_O_TRACECLONE 0x00000008
+#define PTRACE_O_TRACEEXEC 0x00000010
+#define PTRACE_O_TRACEVFORKDONE 0x00000020
+#define PTRACE_O_TRACEEXIT 0x00000040
+#define PTRACE_O_TRACESECCOMP 0x00000080
+#define PTRACE_O_EXITKILL 0x00100000
+#define PTRACE_O_SUSPEND_SECCOMP 0x00200000
+#define PTRACE_O_MASK 0x003000ff
+
+#define PTRACE_EVENT_FORK 1
+#define PTRACE_EVENT_VFORK 2
+#define PTRACE_EVENT_CLONE 3
+#define PTRACE_EVENT_EXEC 4
+#define PTRACE_EVENT_VFORK_DONE 5
+#define PTRACE_EVENT_EXIT 6
+#define PTRACE_EVENT_SECCOMP 7
+#define PTRACE_EVENT_STOP 128
+
+#define PTRACE_PEEKSIGINFO_SHARED 1
+
+#endif /* _ABIBITS_PTRACE_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/random.h mlibc-nomos/sysdeps/nomos/include/abi-bits/random.h
--- mlibc/sysdeps/nomos/include/abi-bits/random.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/random.h	2025-12-08 15:37:43.639962552 +1300
@@ -0,0 +1,14 @@
+#ifndef _ABIBITS_RANDOM_H
+#define _ABIBITS_RANDOM_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "getrandom() is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+#define GRND_NONBLOCK 0x0001
+#define GRND_RANDOM 0x0002
+#define GRND_INSECURE 0x0004
+
+#endif /* _ABIBITS_RANDOM_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/reboot.h mlibc-nomos/sysdeps/nomos/include/abi-bits/reboot.h
--- mlibc/sysdeps/nomos/include/abi-bits/reboot.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/reboot.h	2025-12-29 16:55:29.195633602 +1300
@@ -0,0 +1,12 @@
+#ifndef _ABIBITS_REBOOT_H
+#define _ABIBITS_REBOOT_H
+
+#define RB_AUTOBOOT 0x01234567
+#define RB_HALT_SYSTEM 0xcdef0123
+#define RB_ENABLE_CAD 0x89abcdef
+#define RB_DISABLE_CAD 0
+#define RB_POWER_OFF 0x4321fedc
+#define RB_SW_SUSPEND 0xd000fce2
+#define RB_KEXEC 0x45584543
+
+#endif /* _ABIBITS_REBOOT_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/resource.h mlibc-nomos/sysdeps/nomos/include/abi-bits/resource.h
--- mlibc/sysdeps/nomos/include/abi-bits/resource.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/resource.h	2025-12-08 15:37:43.640018943 +1300
@@ -0,0 +1,72 @@
+#ifndef _ABIBITS_RESOURCE_H
+#define _ABIBITS_RESOURCE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <mlibc-config.h>
+#include <bits/posix/timeval.h>
+
+#if defined(_GNU_SOURCE)
+#define PRIO_MIN (-20)
+#define PRIO_MAX 20
+#endif /* defined(_GNU_SOURCE) */
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+#define PRIO_PROCESS 0
+#define PRIO_PGRP 1
+#define PRIO_USER 2
+
+#define RUSAGE_SELF 0
+#define RUSAGE_CHILDREN -1
+
+#define RLIMIT_CPU 0
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#define RLIMIT_FSIZE 1
+#define RLIMIT_DATA 2
+#define RLIMIT_STACK 3
+#define RLIMIT_CORE 4
+#define RLIMIT_NOFILE 7
+#define RLIMIT_AS 9
+
+#if defined(_DEFAULT_SOURCE)
+#define RLIMIT_RSS 5
+#define RLIMIT_NPROC 6
+#define RLIMIT_MEMLOCK 8
+#define RLIMIT_LOCKS 10
+#define RLIMIT_SIGPENDING 11
+#define RLIMIT_MSGQUEUE 12
+#define RLIMIT_NICE 13
+#define RLIMIT_RTPRIO 14
+#define RLIMIT_RTTIME 15
+#define RLIMIT_NLIMITS 16
+#endif
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+struct rusage {
+	struct timeval ru_utime;
+	struct timeval ru_stime;
+	long ru_maxrss;
+	long ru_ixrss;
+	long ru_idrss;
+	long ru_isrss;
+	long ru_minflt;
+	long ru_majflt;
+	long ru_nswap;
+	long ru_inblock;
+	long ru_oublock;
+	long ru_msgsnd;
+	long ru_msgrcv;
+	long ru_nsignals;
+	long ru_nvcsw;
+	long ru_nivcsw;
+};
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_RESOURCE_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/riscv-hwprobe.h mlibc-nomos/sysdeps/nomos/include/abi-bits/riscv-hwprobe.h
--- mlibc/sysdeps/nomos/include/abi-bits/riscv-hwprobe.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/riscv-hwprobe.h	2025-12-08 15:37:43.640048853 +1300
@@ -0,0 +1,107 @@
+#ifndef _ABIBITS_RISCV_HWPROBE_H
+#define _ABIBITS_RISCV_HWPROBE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct riscv_hwprobe {
+	signed long long int key;
+	unsigned long long int value;
+};
+
+#define RISCV_HWPROBE_KEY_MVENDORID 0
+#define RISCV_HWPROBE_KEY_MARCHID 1
+#define RISCV_HWPROBE_KEY_MIMPID 2
+#define RISCV_HWPROBE_KEY_BASE_BEHAVIOR 3
+#define 	RISCV_HWPROBE_BASE_BEHAVIOR_IMA (1 << 0)
+#define RISCV_HWPROBE_KEY_IMA_EXT_0 4
+#define 	RISCV_HWPROBE_IMA_FD (1 << 0)
+#define 	RISCV_HWPROBE_IMA_C (1 << 1)
+#define 	RISCV_HWPROBE_IMA_V (1 << 2)
+#define 	RISCV_HWPROBE_EXT_ZBA (1 << 3)
+#define 	RISCV_HWPROBE_EXT_ZBB (1 << 4)
+#define 	RISCV_HWPROBE_EXT_ZBS (1 << 5)
+#define 	RISCV_HWPROBE_EXT_ZICBOZ (1 << 6)
+#define 	RISCV_HWPROBE_EXT_ZBC (1 << 7)
+#define 	RISCV_HWPROBE_EXT_ZBKB (1 << 8)
+#define 	RISCV_HWPROBE_EXT_ZBKC (1 << 9)
+#define 	RISCV_HWPROBE_EXT_ZBKX (1 << 10)
+#define 	RISCV_HWPROBE_EXT_ZKND (1 << 11)
+#define 	RISCV_HWPROBE_EXT_ZKNE (1 << 12)
+#define 	RISCV_HWPROBE_EXT_ZKNH (1 << 13)
+#define 	RISCV_HWPROBE_EXT_ZKSED (1 << 14)
+#define 	RISCV_HWPROBE_EXT_ZKSH (1 << 15)
+#define 	RISCV_HWPROBE_EXT_ZKT (1 << 16)
+#define 	RISCV_HWPROBE_EXT_ZVBB (1 << 17)
+#define 	RISCV_HWPROBE_EXT_ZVBC (1 << 18)
+#define 	RISCV_HWPROBE_EXT_ZVKB (1 << 19)
+#define 	RISCV_HWPROBE_EXT_ZVKG (1 << 20)
+#define 	RISCV_HWPROBE_EXT_ZVKNED (1 << 21)
+#define 	RISCV_HWPROBE_EXT_ZVKNHA (1 << 22)
+#define 	RISCV_HWPROBE_EXT_ZVKNHB (1 << 23)
+#define 	RISCV_HWPROBE_EXT_ZVKSED (1 << 24)
+#define 	RISCV_HWPROBE_EXT_ZVKSH (1 << 25)
+#define 	RISCV_HWPROBE_EXT_ZVKT (1 << 26)
+#define 	RISCV_HWPROBE_EXT_ZFH (1 << 27)
+#define 	RISCV_HWPROBE_EXT_ZFHMIN (1 << 28)
+#define 	RISCV_HWPROBE_EXT_ZIHINTNTL (1 << 29)
+#define 	RISCV_HWPROBE_EXT_ZVFH (1 << 30)
+#define 	RISCV_HWPROBE_EXT_ZVFHMIN (1ULL << 31)
+#define 	RISCV_HWPROBE_EXT_ZFA (1ULL << 32)
+#define 	RISCV_HWPROBE_EXT_ZTSO (1ULL << 33)
+#define 	RISCV_HWPROBE_EXT_ZACAS (1ULL << 34)
+#define 	RISCV_HWPROBE_EXT_ZICOND (1ULL << 35)
+#define 	RISCV_HWPROBE_EXT_ZIHINTPAUSE (1ULL << 36)
+#define 	RISCV_HWPROBE_EXT_ZVE32X (1ULL << 37)
+#define 	RISCV_HWPROBE_EXT_ZVE32F (1ULL << 38)
+#define 	RISCV_HWPROBE_EXT_ZVE64X (1ULL << 39)
+#define 	RISCV_HWPROBE_EXT_ZVE64F (1ULL << 40)
+#define 	RISCV_HWPROBE_EXT_ZVE64D (1ULL << 41)
+#define 	RISCV_HWPROBE_EXT_ZIMOP (1ULL << 42)
+#define 	RISCV_HWPROBE_EXT_ZCA (1ULL << 43)
+#define 	RISCV_HWPROBE_EXT_ZCB (1ULL << 44)
+#define 	RISCV_HWPROBE_EXT_ZCD (1ULL << 45)
+#define 	RISCV_HWPROBE_EXT_ZCF (1ULL << 46)
+#define 	RISCV_HWPROBE_EXT_ZCMOP (1ULL << 47)
+#define 	RISCV_HWPROBE_EXT_ZAWRS (1ULL << 48)
+#define 	RISCV_HWPROBE_EXT_SUPM (1ULL << 49)
+#define 	RISCV_HWPROBE_EXT_ZICNTR (1ULL << 50)
+#define 	RISCV_HWPROBE_EXT_ZIHPM (1ULL << 51)
+#define 	RISCV_HWPROBE_EXT_ZFBFMIN (1ULL << 52)
+#define 	RISCV_HWPROBE_EXT_ZVFBFMIN (1ULL << 53)
+#define 	RISCV_HWPROBE_EXT_ZVFBFWMA (1ULL << 54)
+#define 	RISCV_HWPROBE_EXT_ZICBOM (1ULL << 55)
+#define 	RISCV_HWPROBE_EXT_ZAAMO (1ULL << 56)
+#define 	RISCV_HWPROBE_EXT_ZALRSC (1ULL << 57)
+#define 	RISCV_HWPROBE_EXT_ZABHA (1ULL << 58)
+#define RISCV_HWPROBE_KEY_CPUPERF_0 5
+#define 	RISCV_HWPROBE_MISALIGNED_UNKNOWN (0 << 0)
+#define 	RISCV_HWPROBE_MISALIGNED_EMULATED (1 << 0)
+#define 	RISCV_HWPROBE_MISALIGNED_SLOW (2 << 0)
+#define 	RISCV_HWPROBE_MISALIGNED_FAST (3 << 0)
+#define 	RISCV_HWPROBE_MISALIGNED_UNSUPPORTED (4 << 0)
+#define 	RISCV_HWPROBE_MISALIGNED_MASK (7 << 0)
+#define RISCV_HWPROBE_KEY_ZICBOZ_BLOCK_SIZE 6
+#define RISCV_HWPROBE_KEY_HIGHEST_VIRT_ADDRESS 7
+#define RISCV_HWPROBE_KEY_TIME_CSR_FREQ 8
+#define RISCV_HWPROBE_KEY_MISALIGNED_SCALAR_PERF 9
+#define 	RISCV_HWPROBE_MISALIGNED_SCALAR_UNKNOWN 0
+#define 	RISCV_HWPROBE_MISALIGNED_SCALAR_EMULATED 1
+#define 	RISCV_HWPROBE_MISALIGNED_SCALAR_SLOW 2
+#define 	RISCV_HWPROBE_MISALIGNED_SCALAR_FAST 3
+#define 	RISCV_HWPROBE_MISALIGNED_SCALAR_UNSUPPORTED 4
+#define RISCV_HWPROBE_KEY_MISALIGNED_VECTOR_PERF 10
+#define 	RISCV_HWPROBE_MISALIGNED_VECTOR_UNKNOWN 0
+#define 	RISCV_HWPROBE_MISALIGNED_VECTOR_SLOW 2
+#define 	RISCV_HWPROBE_MISALIGNED_VECTOR_FAST 3
+#define 	RISCV_HWPROBE_MISALIGNED_VECTOR_UNSUPPORTED 4
+#define RISCV_HWPROBE_KEY_VENDOR_EXT_THEAD_0 11
+#define RISCV_HWPROBE_KEY_ZICBOM_BLOCK_SIZE 12
+#define RISCV_HWPROBE_KEY_VENDOR_EXT_SIFIVE_0 13
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_RISCV_HWPROBE_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/rlim_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/rlim_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/rlim_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/rlim_t.h	2025-12-08 15:37:43.640082274 +1300
@@ -0,0 +1,10 @@
+#ifndef _ABIBITS_RLIM_T_H
+#define _ABIBITS_RLIM_T_H
+
+#if __INTPTR_WIDTH__ == 32
+typedef unsigned long long int rlim_t;
+#else
+typedef unsigned long int rlim_t;
+#endif
+
+#endif /* _ABIBITS_RLIM_T_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/route.h mlibc-nomos/sysdeps/nomos/include/abi-bits/route.h
--- mlibc/sysdeps/nomos/include/abi-bits/route.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/route.h	2025-12-08 15:37:43.640111075 +1300
@@ -0,0 +1,31 @@
+#ifndef _ABIBITS_ROUTE_H
+#define _ABIBITS_ROUTE_H
+
+#include <sys/socket.h>
+
+#define RTF_HOST 0x0004
+#define RTF_REJECT 0x0200
+
+struct rtentry {
+	unsigned long int rt_pad1;
+	struct sockaddr rt_dst;
+	struct sockaddr rt_gateway;
+	struct sockaddr rt_genmask;
+	unsigned short int rt_flags;
+	short int rt_pad2;
+	unsigned long int rt_pad3;
+	unsigned char rt_tos;
+	unsigned char rt_class;
+#if __INTPTR_WIDTH__ == 64
+	short int rt_pad4[3];
+#else
+	short int rt_pad4;
+#endif
+	short int rt_metric;
+	char *rt_dev;
+	unsigned long int rt_mtu;
+	unsigned long int rt_window;
+	unsigned short int rt_irtt;
+};
+
+#endif /* _ABIBITS_ROUTE_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/sa_family_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/sa_family_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/sa_family_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/sa_family_t.h	2025-12-08 15:37:43.640140595 +1300
@@ -0,0 +1,6 @@
+#ifndef _ABIBITS_SA_FAMILY_T_H
+#define _ABIBITS_SA_FAMILY_T_H
+
+typedef unsigned short sa_family_t;
+
+#endif /* _ABIBITS_SA_FAMILY_T_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/seek-whence.h mlibc-nomos/sysdeps/nomos/include/abi-bits/seek-whence.h
--- mlibc/sysdeps/nomos/include/abi-bits/seek-whence.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/seek-whence.h	2025-12-08 15:37:43.640169276 +1300
@@ -0,0 +1,10 @@
+#ifndef _ABIBITS_SEEK_WHENCE_H
+#define _ABIBITS_SEEK_WHENCE_H
+
+#define SEEK_SET 0
+#define SEEK_CUR 1
+#define SEEK_END 2
+#define SEEK_DATA 3
+#define SEEK_HOLE 4
+
+#endif /* _ABIBITS_SEEK_WHENCE_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/sem.h mlibc-nomos/sysdeps/nomos/include/abi-bits/sem.h
--- mlibc/sysdeps/nomos/include/abi-bits/sem.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/sem.h	2025-12-08 15:37:43.640197736 +1300
@@ -0,0 +1,30 @@
+#ifndef _ABIBITS_SEM_H
+#define _ABIBITS_SEM_H
+
+#include <abi-bits/time.h>
+#include <abi-bits/ipc.h>
+
+#define GETPID 11
+#define GETVAL 12
+#define GETALL 13
+#define SETVAL 16
+#define SETALL 17
+
+#define SEM_UNDO 0x1000
+
+struct sembuf {
+	unsigned short int sem_num;
+	short int sem_op;
+	short int sem_flg;
+};
+
+struct semid_ds {
+	struct ipc_perm sem_perm;
+	time_t          sem_otime;
+	time_t          sem_ctime;
+
+	unsigned long   sem_nsems;
+	unsigned long   __unused[2];
+};
+
+#endif /* _ABIBITS_SEM_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/shm.h mlibc-nomos/sysdeps/nomos/include/abi-bits/shm.h
--- mlibc/sysdeps/nomos/include/abi-bits/shm.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/shm.h	2025-12-08 15:37:43.640225777 +1300
@@ -0,0 +1,104 @@
+#ifndef _ABIBITS_SHM_H
+#define _ABIBITS_SHM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <bits/ansi/time_t.h>
+#include <abi-bits/pid_t.h>
+
+#include <unistd.h>
+#include <sys/ipc.h>
+
+#define SHM_R 0400
+#define SHM_W 0200
+
+#define SHM_RDONLY 010000
+#define SHM_RND 020000
+#define SHM_REMAP 040000
+#define SHM_EXEC 0100000
+
+#define SHM_LOCK 11
+#define SHM_UNLOCK 12
+#define SHM_STAT 13
+#define SHM_INFO 14
+#define SHM_STAT_ANY 15
+#define SHM_DEST 01000
+#define SHM_LOCKED 02000
+#define SHM_HUGETLB 04000
+#define SHM_NORESERVE 010000
+
+#define SHM_HUGE_SHIFT 26
+#define SHM_HUGE_MASK 0x3f
+#define SHM_HUGE_64KB (16 << 26)
+#define SHM_HUGE_512KB (19 << 26)
+#define SHM_HUGE_1MB (20 << 26)
+#define SHM_HUGE_2MB (21 << 26)
+#define SHM_HUGE_8MB (23 << 26)
+#define SHM_HUGE_16MB (24 << 26)
+#define SHM_HUGE_32MB (25 << 26)
+#define SHM_HUGE_256MB (28 << 26)
+#define SHM_HUGE_512MB (29 << 26)
+#define SHM_HUGE_1GB (30 << 26)
+#define SHM_HUGE_2GB (31 << 26)
+#define SHM_HUGE_16GB (34U << 26)
+
+typedef unsigned long shmatt_t;
+
+#if defined(__i386__) || defined(__m68k__)
+struct shmid_ds {
+	struct ipc_perm shm_perm;
+	size_t shm_segsz;
+	unsigned long shm_atime;
+	unsigned long __shm_atime_hi;
+	unsigned long shm_dtime;
+	unsigned long __shm_dtime_hi;
+	unsigned long shm_ctime;
+	unsigned long __shm_ctime_hi;
+	pid_t shm_cpid;
+	pid_t shm_lpid;
+	unsigned long shm_nattch;
+	unsigned long __unused[2];
+};
+#elif defined(__x86_64__) || defined(__aarch64__) || (defined(__riscv) && __riscv_xlen == 64) || defined(__loongarch64)
+struct shmid_ds {
+	struct ipc_perm shm_perm;
+	size_t shm_segsz;
+	time_t shm_atime;
+	time_t shm_dtime;
+	time_t shm_ctime;
+	pid_t shm_cpid;
+	pid_t shm_lpid;
+	unsigned long shm_nattch;
+	unsigned long __unused[2];
+};
+#else
+#error "Missing architecture specific code."
+#endif
+
+struct shminfo {
+	unsigned long shmmax;
+	unsigned long shmmin;
+	unsigned long shmmni;
+	unsigned long shmseg;
+	unsigned long shmall;
+	unsigned long __unused[4];
+};
+
+struct shm_info {
+	int used_ids;
+	unsigned long shm_tot;
+	unsigned long shm_rss;
+	unsigned long shm_swp;
+	unsigned long swap_attempts;
+	unsigned long swap_successes;
+};
+
+#define SHMLBA (getpagesize())
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_SHM_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/sigevent.h mlibc-nomos/sysdeps/nomos/include/abi-bits/sigevent.h
--- mlibc/sysdeps/nomos/include/abi-bits/sigevent.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/sigevent.h	2025-12-08 15:37:43.640282168 +1300
@@ -0,0 +1,24 @@
+#ifndef _ABIBITS_SIGEVENT_H
+#define _ABIBITS_SIGEVENT_H
+
+#include <abi-bits/sigval.h>
+#include <abi-bits/pid_t.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct sigevent {
+	union sigval sigev_value;
+	int sigev_notify;
+	int sigev_signo;
+	void (*sigev_notify_function)(union sigval);
+	struct __mlibc_threadattr *sigev_notify_attributes;
+	pid_t sigev_notify_thread_id;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_SIGEVENT_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/sig-limits.h mlibc-nomos/sysdeps/nomos/include/abi-bits/sig-limits.h
--- mlibc/sysdeps/nomos/include/abi-bits/sig-limits.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/sig-limits.h	2025-12-08 15:37:43.640253937 +1300
@@ -0,0 +1,12 @@
+#ifndef _ABIBITS_SIG_LIMITS_H
+#define _ABIBITS_SIG_LIMITS_H
+
+#include <mlibc-config.h>
+
+#define NSIG_MAX 1024
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+#define NZERO 20
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#endif /*_ABIBITS_SIG_LIMITS_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/signal.h mlibc-nomos/sysdeps/nomos/include/abi-bits/signal.h
--- mlibc/sysdeps/nomos/include/abi-bits/signal.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/signal.h	2025-12-11 13:53:14.624041787 +1300
@@ -0,0 +1,224 @@
+#ifndef _ABIBITS_SIGNAL_H
+#define _ABIBITS_SIGNAL_H
+
+#include <abi-bits/pid_t.h>
+#include <abi-bits/sigevent.h>
+#include <abi-bits/uid_t.h>
+#include <bits/size_t.h>
+#include <stdint.h>
+
+typedef struct {
+	int si_signo;
+	int si_code;
+	int si_errno;
+	pid_t si_pid;
+	uid_t si_uid;
+	void *si_addr;
+	int si_status;
+	long si_band;
+	union sigval si_value;
+} siginfo_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Argument for signal() */
+typedef void (*__sighandler) (int);
+
+#define SIG_ERR ((__sighandler)(void *)(-1))
+#define SIG_DFL ((__sighandler)(void *)(0))
+#define SIG_IGN ((__sighandler)(void *)(1))
+
+
+#define SIGHUP 1
+#define SIGINT 2
+#define SIGQUIT 3
+#define SIGILL 4
+#define SIGTRAP 5
+#define SIGABRT 6
+#define SIGIOT SIGABRT
+#define SIGBUS 7
+#define SIGFPE 8
+#define SIGKILL 9
+#define SIGUSR1 10
+#define SIGSEGV 11
+#define SIGUSR2 12
+#define SIGPIPE 13
+#define SIGALRM 14
+#define SIGTERM 15
+#define SIGSTKFLT 16
+#define SIGCHLD 17
+#define SIGCONT 18
+#define SIGSTOP 19
+#define SIGTSTP 20
+#define SIGTTIN 21
+#define SIGTTOU 22
+#define SIGURG 23
+#define SIGXCPU 24
+#define SIGXFSZ 25
+#define SIGVTALRM 26
+#define SIGPROF 27
+#define SIGWINCH 28
+#define SIGIO 29
+#define SIGPWR 30
+#define SIGSYS 31
+#define SIGUNUSED SIGSYS
+#define SIGCANCEL 32
+#define SIGTIMER 33
+#define SIGRTMIN 34
+#define SIGRTMAX 63
+
+/* siginfo->si_info constants */
+/* SIGBUS */
+#define BUS_ADRALN 1
+#define BUS_ADRERR 2
+#define BUS_OBJERR 3
+
+/* SIGILL */
+#define ILL_ILLOPC 1
+#define ILL_ILLOPN 2
+#define ILL_ILLADR 3
+#define ILL_ILLTRP 4
+#define ILL_PRVOPC 5
+#define ILL_PRVREG 6
+#define ILL_COPROC 7
+#define ILL_BADSTK 8
+#define ILL_BADIADDR 9
+
+/* SIGSEGV */
+#define SEGV_MAPERR 1
+#define SEGV_ACCERR 2
+
+typedef long sigset_t;
+
+/* Constants for sigprocmask() */
+#define SIG_BLOCK 0
+#define SIG_UNBLOCK 1
+#define SIG_SETMASK 2
+
+#define SA_NOCLDSTOP 1
+#define SA_NOCLDWAIT 2
+#define SA_SIGINFO 4
+#define SA_ONSTACK 0x08000000
+#define SA_RESTART 0x10000000
+#define SA_NODEFER 0x40000000
+#define SA_RESETHAND 0x80000000
+#define SA_RESTORER 0x04000000
+
+#define MINSIGSTKSZ 2048
+#define SIGSTKSZ 8192
+#define SS_ONSTACK 1
+#define SS_DISABLE 2
+
+typedef struct __stack {
+    void *ss_sp;
+    size_t ss_size;
+    int ss_flags;
+} stack_t;
+
+/* constants for sigev_notify of struct sigevent */
+#define SIGEV_SIGNAL 0
+#define SIGEV_NONE 1
+#define SIGEV_THREAD 2
+#define SIGEV_THREAD_ID 4
+
+#define SI_ASYNCNL (-60)
+#define SI_TKILL (-6)
+#define SI_SIGIO (-5)
+#define SI_ASYNCIO (-4)
+#define SI_MESGQ (-3)
+#define SI_TIMER (-2)
+#define SI_QUEUE (-1)
+#define SI_USER 0
+#define SI_KERNEL 128
+
+#define NSIG 64
+#define _NSIG NSIG
+
+struct sigaction {
+	union {
+		void (*sa_handler)(int);
+		void (*sa_sigaction)(int, siginfo_t *, void *);
+	};
+	uint64_t sa_flags;
+	void (*sa_restorer)(void);
+	sigset_t sa_mask;
+};
+
+#if defined(__x86_64__)
+
+#define REG_R8 0
+#define REG_R9 1
+#define REG_R10 2
+#define REG_R11 3
+#define REG_R12 4
+#define REG_R13 5
+#define REG_R14 6
+#define REG_R15 7
+#define REG_RDI 8
+#define REG_RSI 9
+#define REG_RBP 10
+#define REG_RBX 11
+#define REG_RDX 12
+#define REG_RAX 13
+#define REG_RCX 14
+#define REG_RSP 15
+#define REG_RIP 16
+#define REG_EFL 17
+#define REG_CSGSFS 18
+#define REG_ERR 19
+#define REG_TRAPNO 20
+#define REG_OLDMASK 21
+#define REG_CR2 22
+#define NGREG 23
+
+struct _fpxreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+	unsigned short padding[3];
+};
+
+struct _xmmreg {
+	uint32_t element[4];
+};
+
+struct _fpstate {
+	uint16_t cwd;
+	uint16_t swd;
+	uint16_t ftw;
+	uint16_t fop;
+	uint64_t rip;
+	uint64_t rdp;
+	uint32_t mxcsr;
+	uint32_t mxcr_mask;
+	struct _fpxreg _st[8];
+	struct _xmmreg _xmm[16];
+	uint32_t padding[24];
+};
+
+typedef struct {
+	unsigned long gregs[NGREG];
+	struct _fpstate *fpregs;
+	unsigned long __reserved1[8];
+} mcontext_t;
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct __ucontext *uc_link;
+	stack_t uc_stack;
+	mcontext_t uc_mcontext;
+	sigset_t uc_sigmask;
+	struct _fpstate __fpregs_mem;
+	unsigned long __ssp[4];
+} ucontext_t;
+
+#else
+#error "Missing architecture specific code."
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_SIGNAL_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/sigval.h mlibc-nomos/sysdeps/nomos/include/abi-bits/sigval.h
--- mlibc/sysdeps/nomos/include/abi-bits/sigval.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/sigval.h	2025-12-08 15:37:43.640350829 +1300
@@ -0,0 +1,17 @@
+#ifndef _ABIBITS_SIGVAL_H
+#define _ABIBITS_SIGVAL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+union sigval {
+	int sival_int;
+	void *sival_ptr;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_SIGVAL_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/sockaddr_storage.h mlibc-nomos/sysdeps/nomos/include/abi-bits/sockaddr_storage.h
--- mlibc/sysdeps/nomos/include/abi-bits/sockaddr_storage.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/sockaddr_storage.h	2025-12-08 15:37:43.640381039 +1300
@@ -0,0 +1,12 @@
+#ifndef _ABIBITS_SOCKADDR_STORAGE_H
+#define _ABIBITS_SOCKADDR_STORAGE_H
+
+#include <abi-bits/sa_family_t.h>
+
+struct sockaddr_storage {
+	sa_family_t ss_family;
+	char __padding[128 - sizeof(sa_family_t) - sizeof(long)];
+	long __force_alignment;
+};
+
+#endif /* _ABIBITS_SOCKADDR_STORAGE_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/socket.h mlibc-nomos/sysdeps/nomos/include/abi-bits/socket.h
--- mlibc/sysdeps/nomos/include/abi-bits/socket.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/socket.h	2025-12-08 15:37:43.640410230 +1300
@@ -0,0 +1,361 @@
+#ifndef _ABIBITS_SOCKET_H
+#define _ABIBITS_SOCKET_H
+
+#include <abi-bits/sa_family_t.h>
+#include <abi-bits/socklen_t.h>
+#include <abi-bits/sockaddr_storage.h>
+#include <bits/size_t.h>
+#include <bits/ssize_t.h>
+#include <bits/posix/iovec.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct msghdr {
+	void *msg_name;
+	socklen_t msg_namelen;
+	struct iovec *msg_iov;
+#if __INTPTR_WIDTH__ == 64 && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	int __pad0;
+#endif
+	int msg_iovlen;
+#if __INTPTR_WIDTH__ == 64 && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	int __pad0;
+#endif
+	void *msg_control;
+#if __INTPTR_WIDTH__ == 64 && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	int __pad1;
+#endif
+	socklen_t msg_controllen;
+#if __INTPTR_WIDTH__ == 64 && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	int __pad1;
+#endif
+	int msg_flags;
+};
+
+#if defined(_GNU_SOURCE)
+struct mmsghdr {
+	struct msghdr msg_hdr;
+	unsigned int  msg_len;
+};
+#endif
+
+struct cmsghdr {
+#if __INTPTR_WIDTH__ == 64 && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	int __pad;
+#endif
+	socklen_t cmsg_len;
+#if __INTPTR_WIDTH__ == 64 && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	int __pad;
+#endif
+	int cmsg_level;
+	int cmsg_type;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#define SCM_RIGHTS 1
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+#define SCM_CREDENTIALS 2
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#define SHUT_RD 0
+#define SHUT_WR 1
+#define SHUT_RDWR 2
+
+#ifndef SOCK_STREAM
+#define SOCK_STREAM    1
+#define SOCK_DGRAM     2
+#endif
+
+#define SOCK_RAW       3
+#define SOCK_SEQPACKET 5
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+#define SOCK_RDM       4
+#define SOCK_DCCP      6
+#define SOCK_PACKET    10
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#ifndef SOCK_CLOEXEC
+#define SOCK_CLOEXEC   02000000
+#define SOCK_NONBLOCK  04000
+#endif
+
+#define AF_UNSPEC       0
+#define AF_UNIX         1
+#define AF_INET         2
+#define AF_INET6        10
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+#define PF_UNSPEC       0
+#define PF_LOCAL        1
+#define PF_UNIX         PF_LOCAL
+#define PF_FILE         PF_LOCAL
+#define PF_INET         2
+#define PF_AX25         3
+#define PF_IPX          4
+#define PF_APPLETALK    5
+#define PF_NETROM       6
+#define PF_BRIDGE       7
+#define PF_ATMPVC       8
+#define PF_X25          9
+#define PF_INET6        10
+#define PF_ROSE         11
+#define PF_DECnet       12
+#define PF_NETBEUI      13
+#define PF_SECURITY     14
+#define PF_KEY          15
+#define PF_NETLINK      16
+#define PF_ROUTE        PF_NETLINK
+#define PF_PACKET       17
+#define PF_ASH          18
+#define PF_ECONET       19
+#define PF_ATMSVC       20
+#define PF_RDS          21
+#define PF_SNA          22
+#define PF_IRDA         23
+#define PF_PPPOX        24
+#define PF_WANPIPE      25
+#define PF_LLC          26
+#define PF_IB           27
+#define PF_MPLS         28
+#define PF_CAN          29
+#define PF_TIPC         30
+#define PF_BLUETOOTH    31
+#define PF_IUCV         32
+#define PF_RXRPC        33
+#define PF_ISDN         34
+#define PF_PHONET       35
+#define PF_IEEE802154   36
+#define PF_CAIF         37
+#define PF_ALG          38
+#define PF_NFC          39
+#define PF_VSOCK        40
+#define PF_KCM          41
+#define PF_QIPCRTR      42
+#define PF_SMC          43
+#define PF_XDP          44
+#define PF_MAX          45
+
+#define AF_LOCAL        PF_LOCAL
+#define AF_FILE         AF_LOCAL
+#define AF_AX25         PF_AX25
+#define AF_IPX          PF_IPX
+#define AF_APPLETALK    PF_APPLETALK
+#define AF_NETROM       PF_NETROM
+#define AF_BRIDGE       PF_BRIDGE
+#define AF_ATMPVC       PF_ATMPVC
+#define AF_X25          PF_X25
+#define AF_ROSE         PF_ROSE
+#define AF_DECnet       PF_DECnet
+#define AF_NETBEUI      PF_NETBEUI
+#define AF_SECURITY     PF_SECURITY
+#define AF_KEY          PF_KEY
+#define AF_NETLINK      PF_NETLINK
+#define AF_ROUTE        PF_ROUTE
+#define AF_PACKET       PF_PACKET
+#define AF_ASH          PF_ASH
+#define AF_ECONET       PF_ECONET
+#define AF_ATMSVC       PF_ATMSVC
+#define AF_RDS          PF_RDS
+#define AF_SNA          PF_SNA
+#define AF_IRDA         PF_IRDA
+#define AF_PPPOX        PF_PPPOX
+#define AF_WANPIPE      PF_WANPIPE
+#define AF_LLC          PF_LLC
+#define AF_IB           PF_IB
+#define AF_MPLS         PF_MPLS
+#define AF_CAN          PF_CAN
+#define AF_TIPC         PF_TIPC
+#define AF_BLUETOOTH    PF_BLUETOOTH
+#define AF_IUCV         PF_IUCV
+#define AF_RXRPC        PF_RXRPC
+#define AF_ISDN         PF_ISDN
+#define AF_PHONET       PF_PHONET
+#define AF_IEEE802154   PF_IEEE802154
+#define AF_CAIF         PF_CAIF
+#define AF_ALG          PF_ALG
+#define AF_NFC          PF_NFC
+#define AF_VSOCK        PF_VSOCK
+#define AF_KCM          PF_KCM
+#define AF_QIPCRTR      PF_QIPCRTR
+#define AF_SMC          PF_SMC
+#define AF_XDP          PF_XDP
+#define AF_MAX          PF_MAX
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#define SO_DEBUG        1
+#define SO_REUSEADDR    2
+#define SO_TYPE         3
+#define SO_ERROR        4
+#define SO_DONTROUTE    5
+#define SO_BROADCAST    6
+#define SO_SNDBUF       7
+#define SO_RCVBUF       8
+#define SO_KEEPALIVE    9
+#define SO_OOBINLINE    10
+#define SO_LINGER       13
+#define SO_RCVLOWAT     18
+#define SO_SNDLOWAT     19
+#define SO_ACCEPTCONN   30
+#define SO_PROTOCOL     38
+#define SO_DOMAIN       39
+
+#ifndef SO_RCVTIMEO
+#if __LONG_MAX__ == 0x7fffffff
+#define SO_RCVTIMEO     66
+#else
+#define SO_RCVTIMEO     20
+#endif
+#endif
+
+#ifndef SO_SNDTIMEO
+#if __LONG_MAX__ == 0x7fffffff
+#define SO_SNDTIMEO     67
+#else
+#define SO_SNDTIMEO     21
+#endif
+#endif
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+#ifndef SO_RCVTIMEO_OLD
+#define SO_RCVTIMEO_OLD 20
+#endif
+
+#ifndef SO_SNDTIMEO_OLD
+#define SO_SNDTIMEO_OLD 21
+#endif
+
+#define SO_NO_CHECK     11
+#define SO_PRIORITY     12
+#define SO_BSDCOMPAT    14
+#define SO_REUSEPORT    15
+#define SO_PASSCRED     16
+#define SO_PEERCRED     17
+#define SO_PEERSEC      31
+#define SO_SNDBUFFORCE  32
+#define SO_RCVBUFFORCE  33
+
+#ifndef SO_TIMESTAMP
+#if __LONG_MAX__ == 0x7fffffff
+#define SO_TIMESTAMP    63
+#define SO_TIMESTAMPNS  64
+#define SO_TIMESTAMPING 65
+#else
+#define SO_TIMESTAMP    29
+#define SO_TIMESTAMPNS  35
+#define SO_TIMESTAMPING 37
+#endif
+#endif
+
+#define SO_SECURITY_AUTHENTICATION              22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT        23
+#define SO_SECURITY_ENCRYPTION_NETWORK          24
+
+#define SO_BINDTODEVICE 25
+
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+#define SO_GET_FILTER           SO_ATTACH_FILTER
+
+#define SO_PEERNAME             28
+#define SCM_TIMESTAMP           SO_TIMESTAMP
+#define SO_PASSSEC              34
+#define SCM_TIMESTAMPNS         SO_TIMESTAMPNS
+#define SO_MARK                 36
+#define SCM_TIMESTAMPING        SO_TIMESTAMPING
+#define SO_RXQ_OVFL             40
+#define SO_WIFI_STATUS          41
+#define SCM_WIFI_STATUS         SO_WIFI_STATUS
+#define SO_PEEK_OFF             42
+#define SO_NOFCS                43
+#define SO_LOCK_FILTER          44
+#define SO_SELECT_ERR_QUEUE     45
+#define SO_BUSY_POLL            46
+#define SO_MAX_PACING_RATE      47
+#define SO_BPF_EXTENSIONS       48
+#define SO_INCOMING_CPU         49
+#define SO_ATTACH_BPF           50
+#define SO_DETACH_BPF           SO_DETACH_FILTER
+#define SO_ATTACH_REUSEPORT_CBPF 51
+#define SO_ATTACH_REUSEPORT_EBPF 52
+#define SO_CNX_ADVICE           53
+#define SCM_TIMESTAMPING_OPT_STATS 54
+#define SO_MEMINFO              55
+#define SO_INCOMING_NAPI_ID     56
+#define SO_COOKIE               57
+#define SCM_TIMESTAMPING_PKTINFO 58
+#define SO_PEERGROUPS           59
+#define SO_ZEROCOPY             60
+#define SO_TXTIME               61
+#define SCM_TXTIME              SO_TXTIME
+#define SO_BINDTOIFINDEX        62
+#define SO_DETACH_REUSEPORT_BPF 68
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#define SOL_SOCKET      1
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+#define SOL_IP          0
+#define SOL_IPV6        41
+#define SOL_ICMPV6      58
+
+#define SOL_RAW         255
+#define SOL_DECNET      261
+#define SOL_X25         262
+#define SOL_PACKET      263
+#define SOL_ATM         264
+#define SOL_AAL         265
+#define SOL_IRDA        266
+#define SOL_NETBEUI     267
+#define SOL_LLC         268
+#define SOL_DCCP        269
+#define SOL_NETLINK     270
+#define SOL_TIPC        271
+#define SOL_RXRPC       272
+#define SOL_PPPOL2TP    273
+#define SOL_BLUETOOTH   274
+#define SOL_PNPIPE      275
+#define SOL_RDS         276
+#define SOL_IUCV        277
+#define SOL_CAIF        278
+#define SOL_ALG         279
+#define SOL_NFC         280
+#define SOL_KCM         281
+#define SOL_TLS         282
+#define SOL_XDP         283
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#define SOMAXCONN       128
+
+#define MSG_OOB       0x0001
+#define MSG_PEEK      0x0002
+#define MSG_DONTROUTE 0x0004
+#define MSG_CTRUNC    0x0008
+#define MSG_TRUNC     0x0020
+#define MSG_EOR       0x0080
+#define MSG_WAITALL   0x0100
+#define MSG_NOSIGNAL  0x4000
+#define MSG_CMSG_CLOEXEC 0x40000000
+
+#if defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN
+#define MSG_PROXY     0x0010
+#define MSG_DONTWAIT  0x0040
+#define MSG_FIN       0x0200
+#define MSG_SYN       0x0400
+#define MSG_CONFIRM   0x0800
+#define MSG_RST       0x1000
+#define MSG_ERRQUEUE  0x2000
+#define MSG_MORE      0x8000
+#define MSG_WAITFORONE 0x10000
+#define MSG_BATCH     0x40000
+#define MSG_ZEROCOPY  0x4000000
+#define MSG_FASTOPEN  0x20000000
+#endif /* defined(_DEFAULT_SOURCE) || __MLIBC_XOPEN */
+
+#endif
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/socklen_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/socklen_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/socklen_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/socklen_t.h	2025-12-08 15:37:43.640444290 +1300
@@ -0,0 +1,6 @@
+#ifndef _ABIBITS_SOCKLEN_T_H
+#define _ABIBITS_SOCKLEN_T_H
+
+typedef unsigned socklen_t;
+
+#endif /* _ABIBITS_SOCKLEN_T_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/statfs.h mlibc-nomos/sysdeps/nomos/include/abi-bits/statfs.h
--- mlibc/sysdeps/nomos/include/abi-bits/statfs.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/statfs.h	2025-12-30 01:21:30.824724259 +1300
@@ -0,0 +1,50 @@
+#ifndef _ABIBITS_STATFS_H
+#define _ABIBITS_STATFS_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "statfs() is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+#include <abi-bits/fsblkcnt_t.h>
+#include <abi-bits/fsfilcnt_t.h>
+
+typedef struct __mlibc_fsid {
+	int __val[2];
+} fsid_t;
+
+/* WARNING: keep `statfs` and `statfs64` in sync or bad things will happen! */
+struct statfs {
+	unsigned long f_type;
+	unsigned long f_bsize;
+	fsblkcnt_t f_blocks;
+	fsblkcnt_t f_bfree;
+	fsblkcnt_t f_bavail;
+	fsfilcnt_t f_files;
+	fsfilcnt_t f_ffree;
+	fsid_t f_fsid;
+	unsigned long f_namelen;
+	unsigned long f_frsize;
+	unsigned long f_flags;
+	unsigned long __f_spare[4];
+};
+
+/* WARNING: keep `statfs` and `statfs64` in sync or bad things will happen! */
+struct statfs64 {
+	unsigned long f_type;
+	unsigned long f_bsize;
+	fsblkcnt_t f_blocks;
+	fsblkcnt_t f_bfree;
+	fsblkcnt_t f_bavail;
+	fsfilcnt_t f_files;
+	fsfilcnt_t f_ffree;
+	fsid_t f_fsid;
+	unsigned long f_namelen;
+	unsigned long f_frsize;
+	unsigned long f_flags;
+	unsigned long __f_spare[4];
+};
+
+#endif /* _ABIBITS_STATFS_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/stat.h mlibc-nomos/sysdeps/nomos/include/abi-bits/stat.h
--- mlibc/sysdeps/nomos/include/abi-bits/stat.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/stat.h	2025-12-08 20:36:42.195854843 +1300
@@ -0,0 +1,69 @@
+#ifndef _ABIBITS_STAT_H
+#define _ABIBITS_STAT_H
+
+#include <abi-bits/uid_t.h>
+#include <abi-bits/gid_t.h>
+#include <bits/off_t.h>
+#include <abi-bits/mode_t.h>
+#include <abi-bits/dev_t.h>
+#include <abi-bits/ino_t.h>
+#include <abi-bits/blksize_t.h>
+#include <abi-bits/blkcnt_t.h>
+#include <abi-bits/nlink_t.h>
+#include <bits/ansi/time_t.h>
+#include <bits/ansi/timespec.h>
+
+#define S_IFMT 0x0F000
+#define S_IFBLK 0x06000
+#define S_IFCHR 0x02000
+#define S_IFIFO 0x01000
+#define S_IFREG 0x08000
+#define S_IFDIR 0x04000
+#define S_IFLNK 0x0A000
+#define S_IFSOCK 0x0C000
+
+#define S_IRWXU 0700
+#define S_IRUSR 0400
+#define S_IWUSR 0200
+#define S_IXUSR 0100
+#define S_IRWXG 070
+#define S_IRGRP 040
+#define S_IWGRP 020
+#define S_IXGRP 010
+#define S_IRWXO 07
+#define S_IROTH 04
+#define S_IWOTH 02
+#define S_IXOTH 01
+#define S_ISUID 04000
+#define S_ISGID 02000
+#define S_ISVTX 01000
+
+#define S_IREAD  S_IRUSR
+#define S_IWRITE S_IWUSR
+#define S_IEXEC  S_IXUSR
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct stat {
+	dev_t st_dev;
+	ino_t st_ino;
+	nlink_t st_nlink;
+	mode_t st_mode;
+	uid_t st_uid;
+	gid_t st_gid;
+	dev_t st_rdev;
+	off_t st_size;
+	blksize_t st_blksize;
+	blkcnt_t st_blocks;
+	struct timespec st_atim;
+	struct timespec st_mtim;
+	struct timespec st_ctim;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_STAT_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/statvfs.h mlibc-nomos/sysdeps/nomos/include/abi-bits/statvfs.h
--- mlibc/sysdeps/nomos/include/abi-bits/statvfs.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/statvfs.h	2025-12-08 15:37:43.640536562 +1300
@@ -0,0 +1,64 @@
+#ifndef _ABIBITS_STATVFS_H
+#define _ABIBITS_STATVFS_H
+
+#include <mlibc-config.h>
+
+#include <abi-bits/fsblkcnt_t.h>
+#include <abi-bits/fsfilcnt_t.h>
+
+#define ST_RDONLY 1
+#define ST_NOSUID 2
+#define ST_NODEV 4
+#define ST_NOEXEC 8
+#define ST_SYNCHRONOUS 16
+#define ST_MANDLOCK 64
+#define ST_WRITE 128
+#define ST_APPEND 256
+#define ST_IMMUTABLE 512
+#define ST_NOATIME 1024
+#define ST_NODIRATIME 2048
+
+/* On Linux, this struct is not directly used by the kernel. */
+
+/* WARNING: keep `statvfs` and `statvfs64` in sync or bad things will happen! */
+struct statvfs {
+	unsigned long f_bsize;
+	unsigned long f_frsize;
+	fsblkcnt_t f_blocks;
+	fsblkcnt_t f_bfree;
+	fsblkcnt_t f_bavail;
+	fsfilcnt_t f_files;
+	fsfilcnt_t f_ffree;
+	fsfilcnt_t f_favail;
+	unsigned long f_fsid;
+#if __INTPTR_WIDTH__ == 32
+	int __f_unused;
+#endif
+	unsigned long f_flag;
+	unsigned long f_namemax;
+	unsigned int f_spare[6];
+};
+
+#if __MLIBC_LINUX_OPTION && defined(_LARGEFILE64_SOURCE)
+/* WARNING: keep `statvfs` and `statvfs64` in sync or bad things will happen! */
+struct statvfs64 {
+	unsigned long f_bsize;
+	unsigned long f_frsize;
+	fsblkcnt_t f_blocks;
+	fsblkcnt_t f_bfree;
+	fsblkcnt_t f_bavail;
+	fsfilcnt_t f_files;
+	fsfilcnt_t f_ffree;
+	fsfilcnt_t f_favail;
+	unsigned long f_fsid;
+#if __INTPTR_WIDTH__ == 32
+	int __f_unused;
+#endif
+	unsigned long f_flag;
+	unsigned long f_namemax;
+	unsigned int f_spare[6];
+};
+#endif /* __MLIBC_LINUX_OPTION && defined(_LARGEFILE64_SOURCE) */
+
+#endif /* _ABIBITS_STATVFS_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/statx.h mlibc-nomos/sysdeps/nomos/include/abi-bits/statx.h
--- mlibc/sysdeps/nomos/include/abi-bits/statx.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/statx.h	2025-12-08 15:37:43.640565323 +1300
@@ -0,0 +1,77 @@
+#ifndef _ABIBITS_STATX_H
+#define _ABIBITS_STATX_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "statx() is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+#include <bits/types.h>
+
+struct statx_timestamp {
+	__mlibc_int64 tv_sec;
+	__mlibc_uint32 tv_nsec;
+	__mlibc_uint32 __padding;
+};
+
+#define STATX_TYPE 0x1
+#define STATX_MODE 0x2
+#define STATX_NLINK 0x4
+#define STATX_UID 0x8
+#define STATX_GID 0x10
+#define STATX_ATIME 0x20
+#define STATX_MTIME 0x40
+#define STATX_CTIME 0x80
+#define STATX_INO 0x100
+#define STATX_SIZE 0x200
+#define STATX_BLOCKS 0x400
+#define STATX_BASIC_STATS 0x7ff
+#define STATX_BTIME 0x800
+#define STATX_MNT_ID 0x1000
+#define STATX_DIOALIGN 0x2000
+#define STATX_ALL 0xfff
+
+#define STATX_ATTR_COMPRESSED 0x4
+#define STATX_ATTR_IMMUTABLE 0x10
+#define STATX_ATTR_APPEND 0x20
+#define STATX_ATTR_NODUMP 0x40
+#define STATX_ATTR_ENCRYPTED 0x800
+#define STATX_ATTR_AUTOMOUNT 0x1000
+#define STATX_ATTR_MOUNT_ROOT 0x2000
+#define STATX_ATTR_VERITY 0x100000
+#define STATX_ATTR_DAX 0x200000
+
+struct statx {
+	__mlibc_uint32 stx_mask;
+
+	__mlibc_uint32 stx_blksize;
+	__mlibc_uint64 stx_attributes;
+	__mlibc_uint32 stx_nlink;
+	__mlibc_uint32 stx_uid;
+	__mlibc_uint32 stx_gid;
+	__mlibc_uint16 stx_mode;
+	__mlibc_uint16 __padding;
+	__mlibc_uint64 stx_ino;
+	__mlibc_uint64 stx_size;
+	__mlibc_uint64 stx_blocks;
+	__mlibc_uint64 stx_attributes_mask;
+
+	struct statx_timestamp stx_atime;
+	struct statx_timestamp stx_btime;
+	struct statx_timestamp stx_ctime;
+	struct statx_timestamp stx_mtime;
+
+	__mlibc_uint32 stx_rdev_major;
+	__mlibc_uint32 stx_rdev_minor;
+	__mlibc_uint32 stx_dev_major;
+	__mlibc_uint32 stx_dev_minor;
+
+	__mlibc_uint64 stx_mnt_id;
+	__mlibc_uint32 stx_dio_mem_align;
+	__mlibc_uint32 stx_dio_offset_align;
+
+	__mlibc_uint64 __padding1[12];
+};
+
+#endif
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/suseconds_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/suseconds_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/suseconds_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/suseconds_t.h	2025-12-08 15:37:43.640594653 +1300
@@ -0,0 +1,8 @@
+#ifndef _ABIBITS_SUSECONDS_T_H
+#define _ABIBITS_SUSECONDS_T_H
+
+#include <bits/types.h>
+
+typedef long suseconds_t;
+
+#endif /* _ABIBITS_SUSECONDS_T_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/termios.h mlibc-nomos/sysdeps/nomos/include/abi-bits/termios.h
--- mlibc/sysdeps/nomos/include/abi-bits/termios.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/termios.h	2025-12-08 15:37:43.640632094 +1300
@@ -0,0 +1,145 @@
+#ifndef _ABIBITS_TERMIOS_H
+#define _ABIBITS_TERMIOS_H
+
+typedef unsigned char cc_t;
+typedef unsigned int speed_t;
+typedef unsigned int tcflag_t;
+
+/* indices for the c_cc array in struct termios */
+#define NCCS     32
+#define VINTR    0
+#define VQUIT    1
+#define VERASE   2
+#define VKILL    3
+#define VEOF     4
+#define VTIME    5
+#define VMIN     6
+#define VSWTC    7
+#define VSTART   8
+#define VSTOP    9
+#define VSUSP    10
+#define VEOL     11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE  14
+#define VLNEXT   15
+#define VEOL2    16
+
+/* bitwise flags for c_iflag in struct termios */
+#define IGNBRK 0000001
+#define BRKINT 0000002
+#define IGNPAR 0000004
+#define PARMRK 0000010
+#define INPCK 0000020
+#define ISTRIP 0000040
+#define INLCR 0000100
+#define IGNCR 0000200
+#define ICRNL 0000400
+#define IUCLC 0001000
+#define IXON 0002000
+#define IXANY 0004000
+#define IXOFF 0010000
+#define IMAXBEL 0020000
+#define IUTF8 0040000
+
+/* bitwise flags for c_oflag in struct termios */
+#define OPOST 0000001
+#define OLCUC 0000002
+#define ONLCR 0000004
+#define OCRNL 0000010
+#define ONOCR 0000020
+#define ONLRET 0000040
+#define OFILL 0000100
+#define OFDEL 0000200
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) || defined(_XOPEN_SOURCE)
+
+#define NLDLY 0000400
+#define NL0 0000000
+#define NL1 0000400
+
+#define CRDLY 0003000
+#define CR0 0000000
+#define CR1 0001000
+#define CR2 0002000
+#define CR3 0003000
+
+#define TABDLY 0014000
+#define TAB0 0000000
+#define TAB1 0004000
+#define TAB2 0010000
+#define TAB3 0014000
+
+#define BSDLY 0020000
+#define BS0 0000000
+#define BS1 0020000
+
+#define FFDLY 0100000
+#define FF0 0000000
+#define FF1 0100000
+
+#endif
+
+#define VTDLY 0040000
+#define VT0 0000000
+#define VT1 0040000
+
+/* bitwise constants for c_cflag in struct termios */
+#define CSIZE 0000060
+#define CS5 0000000
+#define CS6 0000020
+#define CS7 0000040
+#define CS8 0000060
+
+#define CSTOPB 0000100
+#define CREAD 0000200
+#define PARENB 0000400
+#define PARODD 0001000
+#define HUPCL 0002000
+#define CLOCAL 0004000
+
+/* bitwise constants for c_lflag in struct termios */
+#define ISIG 0000001
+#define ICANON 0000002
+#define ECHO 0000010
+#define ECHOE 0000020
+#define ECHOK 0000040
+#define ECHONL 0000100
+#define NOFLSH 0000200
+#define TOSTOP 0000400
+#define IEXTEN 0100000
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#define EXTA    0000016
+#define EXTB    0000017
+#define CBAUD   0010017
+#define CBAUDEX 0010000
+#define CIBAUD  002003600000
+#define CMSPAR  010000000000
+#define CRTSCTS 020000000000
+
+#define XCASE   0000004
+#define ECHOCTL 0001000
+#define ECHOPRT 0002000
+#define ECHOKE  0004000
+#define FLUSHO  0010000
+#define PENDIN  0040000
+#define EXTPROC 0200000
+
+#define XTABS 0014000
+
+#endif
+
+struct termios {
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t c_line;
+	cc_t c_cc[NCCS];
+	speed_t c_ibaud;
+	speed_t c_obaud;
+};
+
+#endif
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/time.h mlibc-nomos/sysdeps/nomos/include/abi-bits/time.h
--- mlibc/sysdeps/nomos/include/abi-bits/time.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/time.h	2025-12-08 15:37:43.640662614 +1300
@@ -0,0 +1,15 @@
+#ifndef _ABIBITS_TIME_H
+#define _ABIBITS_TIME_H
+
+#include <bits/posix/timeval.h>
+
+struct itimerval {
+	struct timeval it_interval;	/* Interval for periodic timer */
+	struct timeval it_value;	/* Time until next expiration */
+};
+
+#define ITIMER_REAL	0
+#define ITIMER_VIRTUAL	1
+#define ITIMER_PROF	2
+
+#endif /* _ABIBITS_TIME_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/uid_t.h mlibc-nomos/sysdeps/nomos/include/abi-bits/uid_t.h
--- mlibc/sysdeps/nomos/include/abi-bits/uid_t.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/uid_t.h	2025-12-08 15:37:43.640691625 +1300
@@ -0,0 +1,8 @@
+
+#ifndef _ABIBITS_UID_T_H
+#define _ABIBITS_UID_T_H
+
+typedef unsigned int uid_t;
+
+#endif /* _ABIBITS_UID_T_H */
+
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/utmp-defines.h mlibc-nomos/sysdeps/nomos/include/abi-bits/utmp-defines.h
--- mlibc/sysdeps/nomos/include/abi-bits/utmp-defines.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/utmp-defines.h	2025-12-08 15:37:43.640720755 +1300
@@ -0,0 +1,25 @@
+#ifndef _ABIBITS_UTMP_DEFINES_H
+#define _ABIBITS_UTMP_DEFINES_H
+
+#include <mlibc-config.h>
+
+#define EMPTY 0
+#define RUN_LVL 1
+#define BOOT_TIME 2
+#define NEW_TIME 3
+#define OLD_TIME 4
+#define INIT_PROCESS 5
+#define LOGIN_PROCESS 6
+#define USER_PROCESS 7
+#define DEAD_PROCESS 8
+
+#ifdef _GNU_SOURCE
+#define ACCOUNTING 9
+#endif
+
+#if __MLIBC_LINUX_OPTION
+#define UTMP_FILE "/var/run/utmp"
+#define WTMP_FILE "/var/log/wtmp"
+#endif /* __MLIBC_LINUX_OPTION */
+
+#endif /* _ABIBITS_UTMP_DEFINES_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/utmpx.h mlibc-nomos/sysdeps/nomos/include/abi-bits/utmpx.h
--- mlibc/sysdeps/nomos/include/abi-bits/utmpx.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/utmpx.h	2025-12-08 15:37:43.640749976 +1300
@@ -0,0 +1,36 @@
+#ifndef _ABIBITS_UTMPX_H
+#define _ABIBITS_UTMPX_H
+
+#include <abi-bits/pid_t.h>
+#include <bits/posix/timeval.h>
+
+#define __UT_HOSTSIZE 256
+#define __UT_NAMESIZE 32
+#define __UT_LINESIZE 32
+
+/* Struct definition taken from musl */
+struct utmpx {
+	short ut_type;
+	short __ut_pad1;
+	pid_t ut_pid;
+	char ut_line[__UT_LINESIZE];
+	char ut_id[4];
+	char ut_user[__UT_NAMESIZE];
+	char ut_host[__UT_HOSTSIZE];
+	struct {
+		short __e_termination;
+		short __e_exit;
+	} ut_exit;
+	int ut_session, __ut_pad2;
+	struct timeval ut_tv;
+	unsigned ut_addr_v6[4];
+	char __unused[20];
+};
+
+#define e_exit __e_exit
+#define e_termination __e_termination
+
+#define UTMPX_FILE "/var/run/utmp"
+#define WTMPX_FILE "/var/log/wtmp"
+
+#endif /* _ABIBITS_UTMPX_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/utsname.h mlibc-nomos/sysdeps/nomos/include/abi-bits/utsname.h
--- mlibc/sysdeps/nomos/include/abi-bits/utsname.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/utsname.h	2025-12-08 15:37:43.640779176 +1300
@@ -0,0 +1,17 @@
+#ifndef _ABIBITS_UTSNAME_T_H
+#define _ABIBITS_UTSNAME_T_H
+
+struct utsname {
+	char sysname[65];
+	char nodename[65];
+	char release[65];
+	char version[65];
+	char machine[65];
+#if defined(_GNU_SOURCE)
+	char domainname[65];
+#else
+	char __domainname[65];
+#endif
+};
+
+#endif /* _ABIBITS_UTSNAME_T_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/vm-flags.h mlibc-nomos/sysdeps/nomos/include/abi-bits/vm-flags.h
--- mlibc/sysdeps/nomos/include/abi-bits/vm-flags.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/vm-flags.h	2025-12-08 15:37:43.640808527 +1300
@@ -0,0 +1,85 @@
+#ifndef _ABIBITS_VM_FLAGS_H
+#define _ABIBITS_VM_FLAGS_H
+
+#include <mlibc-config.h>
+
+#define PROT_NONE  0x00
+#define PROT_READ  0x01
+#define PROT_WRITE 0x02
+#define PROT_EXEC  0x04
+
+#define MAP_FAILED ((void *)(-1))
+#define MAP_FILE    0x00
+#define MAP_SHARED    0x01
+#define MAP_PRIVATE   0x02
+#define MAP_FIXED     0x10
+#define MAP_ANON      0x20
+#define MAP_ANONYMOUS 0x20
+
+#if __MLIBC_LINUX_OPTION
+
+#define MAP_GROWSDOWN 0x100
+#define MAP_DENYWRITE 0x800
+#define MAP_EXECUTABLE 0x1000
+#define MAP_LOCKED    0x2000
+#define MAP_NORESERVE 0x4000
+#define MAP_POPULATE  0x8000
+#define MAP_NONBLOCK  0x10000
+#define MAP_STACK     0x20000
+#define MAP_HUGETLB   0x40000
+#define MAP_SYNC      0x80000
+#define MAP_FIXED_NOREPLACE 0x100000
+
+#endif /* __MLIBC_LINUX_OPTION */
+
+#define MS_ASYNC 0x01
+#define MS_INVALIDATE 0x02
+#define MS_SYNC 0x04
+
+#define MCL_CURRENT 0x01
+#define MCL_FUTURE 0x02
+
+#define POSIX_MADV_NORMAL 0
+#define POSIX_MADV_RANDOM 1
+#define POSIX_MADV_SEQUENTIAL 2
+#define POSIX_MADV_WILLNEED 3
+#define POSIX_MADV_DONTNEED 4
+
+#if __MLIBC_LINUX_OPTION
+
+#if defined(_DEFAULT_SOURCE)
+#define MADV_NORMAL 0
+#define MADV_RANDOM 1
+#define MADV_SEQUENTIAL 2
+#define MADV_WILLNEED 3
+#define MADV_DONTNEED 4
+#define MADV_FREE 8
+#define MADV_REMOVE 9
+#define MADV_DONTFORK 10
+#define MADV_DOFORK 11
+#define MADV_MERGEABLE 12
+#define MADV_UNMERGEABLE 13
+#define MADV_HUGEPAGE 14
+#define MADV_NOHUGEPAGE 15
+#define MADV_DONTDUMP 16
+#define MADV_DODUMP 17
+#define MADV_WIPEONFORK 18
+#define MADV_KEEPONFORK 19
+#define MADV_COLD 20
+#define MADV_PAGEOUT 21
+#define MADV_HWPOISON 100
+#define MADV_SOFT_OFFLINE 101
+#endif /* defined(_DEFAULT_SOURCE) */
+
+#if defined(_GNU_SOURCE)
+#define MREMAP_MAYMOVE 1
+#define MREMAP_FIXED 2
+
+#define MFD_CLOEXEC 1U
+#define MFD_ALLOW_SEALING 2U
+#define MFD_HUGETLB 4U
+#endif /* defined(_GNU_SOURCE) */
+
+#endif /* __MLIBC_LINUX_OPTION */
+
+#endif /* _ABIBITS_VM_FLAGS_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/vt.h mlibc-nomos/sysdeps/nomos/include/abi-bits/vt.h
--- mlibc/sysdeps/nomos/include/abi-bits/vt.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/vt.h	2025-12-08 15:37:43.640837867 +1300
@@ -0,0 +1,82 @@
+#ifndef _ABIBITS_VT_H
+#define _ABIBITS_VT_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "<linux/vt.h> is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+#define MIN_NR_CONSOLES 1
+#define MAX_NR_CONSOLES 63
+
+#define VT_OPENQRY 0x5600
+#define VT_GETMODE 0x5601
+#define VT_SETMODE 0x5602
+#define VT_GETSTATE 0x5603
+#define VT_SENDSIG 0x5604
+#define VT_RELDISP 0x5605
+#define VT_ACTIVATE 0x5606
+#define VT_WAITACTIVE 0x5607
+#define VT_DISALLOCATE 0x5608
+#define VT_RESIZE 0x5609
+#define VT_RESIZEX 0x560A
+#define VT_LOCKSWITCH 0x560B
+#define VT_UNLOCKSWITCH 0x560C
+#define VT_GETHIFONTMASK 0x560D
+#define VT_WAITEVENT 0x560E
+#define VT_SETACTIVATE 0x560F
+
+struct vt_mode {
+  char mode;
+  char waitv;
+  short relsig;
+  short acqsig;
+  short frsig;
+};
+
+#define VT_AUTO 0x00
+#define VT_PROCESS 0x01
+#define VT_ACKACQ 0x02
+
+struct vt_stat {
+  unsigned short v_active;
+  unsigned short v_signal;
+  unsigned short v_state;
+};
+
+struct vt_sizes {
+  unsigned short v_rows;
+  unsigned short v_cols;
+  unsigned short v_scrollsize;
+};
+
+struct vt_consize {
+  unsigned short v_rows;
+  unsigned short v_cols;
+  unsigned short v_vlin;
+  unsigned short v_clin;
+  unsigned short v_vcol;
+  unsigned short v_ccol;
+};
+
+#define VT_EVENT_SWITCH 0x0001
+#define VT_EVENT_BLANK 0x0002
+#define VT_EVENT_UNBLANK 0x0004
+#define VT_EVENT_RESIZE 0x0008
+#define VT_MAX_EVENT 0x000F
+
+struct vt_event {
+  unsigned int event;
+
+  unsigned int oldev;
+  unsigned int newev;
+  unsigned int pad[4];
+};
+
+struct vt_setactivate {
+  unsigned int console;
+  struct vt_mode mode;
+};
+
+#endif /* _ABIBITS_VT_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/wait.h mlibc-nomos/sysdeps/nomos/include/abi-bits/wait.h
--- mlibc/sysdeps/nomos/include/abi-bits/wait.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/wait.h	2025-12-08 15:37:43.640866788 +1300
@@ -0,0 +1,34 @@
+#ifndef _ABIBITS_WAIT_H
+#define _ABIBITS_WAIT_H
+
+#include <mlibc-config.h>
+
+#define WNOHANG 1
+#define WUNTRACED 2
+#define WSTOPPED 2
+#define WEXITED 4
+#define WCONTINUED 8
+#define WNOWAIT 0x01000000
+
+#if __MLIBC_LINUX_OPTION
+
+#define __WALL 0x40000000
+#define __WCLONE 0x80000000
+
+#endif /* __MLIBC_LINUX_OPTION */
+
+#define WCOREFLAG 0x80
+
+#define WEXITSTATUS(x) (((x) & 0xff00) >> 8)
+#define WTERMSIG(x) ((x) & 0x7f)
+#define WSTOPSIG(x) WEXITSTATUS(x)
+#define WIFEXITED(x) (WTERMSIG(x) == 0)
+#define WIFSIGNALED(x) (((signed char) (((x) & 0x7f) + 1) >> 1) > 0)
+#define WIFSTOPPED(x) (((x) & 0xff) == 0x7f)
+#define WIFCONTINUED(x) ((x) == 0xffff)
+#define WCOREDUMP(x) ((x) & WCOREFLAG)
+
+/* glibc extension, but also useful for kernels */
+#define W_EXITCODE(ret, sig) (((ret) << 8) | (sig))
+
+#endif /*_ABIBITS_WAIT_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/abi-bits/xattr.h mlibc-nomos/sysdeps/nomos/include/abi-bits/xattr.h
--- mlibc/sysdeps/nomos/include/abi-bits/xattr.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/abi-bits/xattr.h	2025-12-08 15:37:43.640895778 +1300
@@ -0,0 +1,27 @@
+#ifndef MLIBC_ABIS_LINUX_XATTR_H
+#define MLIBC_ABIS_LINUX_XATTR_H
+
+#include <mlibc-config.h>
+
+#if !__MLIBC_LINUX_OPTION
+#  error "<sys/xattr.h> is inherently Linux specific. Enable the Linux option or do not use this header."
+#endif /* !__MLIBC_LINUX_OPTION */
+
+/* __USE_KERNEL_XATTR_DEFS is exported when XATTR_* are emitted, and
+ * __UAPI_DEF_XATTR is used to determine the behaviour of the
+ * <linux/xattr.h> header (through <linux/libc-compat.h>), if it's set
+ * to 1, the header exports xattr defines and __USE_KERNEL_XATTR_DEFS.
+ * This applies for pretty much all other defines in libc-compat.h
+ * AFAICT.
+ */
+#ifndef __USE_KERNEL_XATTR_DEFS
+enum {
+	XATTR_CREATE = 1,
+#define XATTR_CREATE XATTR_CREATE
+	XATTR_REPLACE = 2
+#define XATTR_REPLACE XATTR_REPLACE
+};
+#	define __UAPI_DEF_XATTR 0
+#endif
+
+#endif /* MLIBC_ABIS_LINUX_XATTR_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/asm/ioctls.h mlibc-nomos/sysdeps/nomos/include/asm/ioctls.h
--- mlibc/sysdeps/nomos/include/asm/ioctls.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/asm/ioctls.h	2025-12-08 14:38:15.126115839 +1300
@@ -0,0 +1,25 @@
+#ifndef _ASM_IOCTLS_H
+#define _ASM_IOCTLS_H
+
+#define TCGETS          0x5401
+#define TCSETS          0x5402
+#define TCSETSW         0x5403
+#define TCSETSF         0x5404
+#define TCGETA          0x5405
+#define TCSETA          0x5406
+#define TCSETAW         0x5407
+#define TCSETAF         0x5408
+#define TCSBRK          0x5409
+#define TCXONC          0x540a
+#define TCFLSH          0x540b
+#define TIOCEXCL        0x540c
+#define TIOCNXCL        0x540d
+#define TIOCSCTTY       0x540e
+#define TIOCGPGRP       0x540f
+#define TIOCSPGRP       0x5410
+#define TIOCOUTQ        0x5411
+#define TIOCSTI         0x5412
+#define TIOCGWINSZ      0x5413
+#define TIOCSWINSZ      0x5414
+
+#endif /* _ASM_IOCTLS_H */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/linux/fb.h mlibc-nomos/sysdeps/nomos/include/linux/fb.h
--- mlibc/sysdeps/nomos/include/linux/fb.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/linux/fb.h	2025-12-16 22:05:25.138446014 +1300
@@ -0,0 +1,398 @@
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+#define FB_TYPE_FOURCC			5	/* Type identified by a V4L2 FOURCC */
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+#define FB_VISUAL_FOURCC		6	/* Visual identified by a V4L2 FOURCC */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+#define FB_ACCEL_PUV3_UNIGFX	0xa0	/* PKUnity-v3 Unigfx		*/
+
+#define FB_CAP_FOURCC		1	/* Device supports FOURCC-based formats */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	uint32_t smem_len;			/* Length of frame buffer mem */
+	uint32_t type;			/* see FB_TYPE_*		*/
+	uint32_t type_aux;			/* Interleave for interleaved Planes */
+	uint32_t visual;			/* see FB_VISUAL_*		*/
+	uint16_t xpanstep;			/* zero if no hardware panning  */
+	uint16_t ypanstep;			/* zero if no hardware panning  */
+	uint16_t ywrapstep;		/* zero if no hardware ywrap    */
+	uint32_t line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	uint32_t mmio_len;			/* Length of Memory Mapped I/O  */
+	uint32_t accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	uint16_t capabilities;		/* see FB_CAP_*			*/
+	uint16_t reserved[2];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the palette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
+ */
+struct fb_bitfield {
+	uint32_t offset;			/* beginning of bitfield	*/
+	uint32_t length;			/* length of bitfield		*/
+	uint32_t msb_right;		/* != 0 : Most significant bit is */
+					/* right */
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+#define FB_ACTIVATE_KD_TEXT   512       /* for KDSET vt ioctl */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	uint32_t xres;			/* visible resolution		*/
+	uint32_t yres;
+	uint32_t xres_virtual;		/* virtual resolution		*/
+	uint32_t yres_virtual;
+	uint32_t xoffset;			/* offset from virtual to visible */
+	uint32_t yoffset;			/* resolution			*/
+
+	uint32_t bits_per_pixel;		/* guess what			*/
+	uint32_t grayscale;		/* 0 = color, 1 = grayscale,	*/
+					/* >1 = FOURCC			*/
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/
+
+	uint32_t nonstd;			/* != 0 Non standard pixel format */
+
+	uint32_t activate;			/* see FB_ACTIVATE_*		*/
+
+	uint32_t height;			/* height of picture in mm    */
+	uint32_t width;			/* width of picture in mm     */
+
+	uint32_t accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	uint32_t pixclock;			/* pixel clock in ps (pico seconds) */
+	uint32_t left_margin;		/* time from sync to picture	*/
+	uint32_t right_margin;		/* time from picture to sync	*/
+	uint32_t upper_margin;		/* time from sync to picture	*/
+	uint32_t lower_margin;
+	uint32_t hsync_len;		/* length of horizontal sync	*/
+	uint32_t vsync_len;		/* length of vertical sync	*/
+	uint32_t sync;			/* see FB_SYNC_*		*/
+	uint32_t vmode;			/* see FB_VMODE_*		*/
+	uint32_t rotate;			/* angle we rotate counter clockwise */
+	uint32_t colorspace;		/* colorspace for FOURCC-based modes */
+	uint32_t reserved[4];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	uint32_t start;			/* First entry	*/
+	uint32_t len;			/* Number of entries */
+	uint16_t *red;			/* Red values	*/
+	uint16_t *green;
+	uint16_t *blue;
+	uint16_t *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	uint32_t console;
+	uint32_t framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	uint32_t flags;			/* FB_VBLANK flags */
+	uint32_t count;			/* counter of retraces since boot */
+	uint32_t vcount;			/* current scanline position */
+	uint32_t hcount;			/* current scandot position */
+	uint32_t reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	uint32_t dx;
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t sx;
+	uint32_t sy;
+};
+
+struct fb_fillrect {
+	uint32_t dx;	/* screen-relative */
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t color;
+	uint32_t rop;
+};
+
+struct fb_image {
+	uint32_t dx;		/* Where to place image */
+	uint32_t dy;
+	uint32_t width;		/* Size of image */
+	uint32_t height;
+	uint32_t fg_color;		/* Only used when a mono bitmap */
+	uint32_t bg_color;
+	uint8_t  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	uint16_t x, y;
+};
+
+struct fb_cursor {
+	uint16_t set;		/* what to set */
+	uint16_t enable;		/* cursor on/off */
+	uint16_t rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+
+
+#endif /* _LINUX_FB_H */
\ No newline at end of file
diff -urN --no-dereference mlibc/sysdeps/nomos/include/nomos/syscall.h mlibc-nomos/sysdeps/nomos/include/nomos/syscall.h
--- mlibc/sysdeps/nomos/include/nomos/syscall.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/nomos/syscall.h	2026-01-22 16:40:51.709383858 +1300
@@ -0,0 +1,102 @@
+#ifndef _NOMOS__SYSCALL_H_
+#define _NOMOS__SYSCALL_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define SYSCALL_EXIT        0
+#define SYSCALL_PRCTL       1
+#define SYSCALL_DEBUG       2
+#define SYSCALL_MMAP        3
+#define SYSCALL_MUNMAP      4
+#define SYSCALL_MPROTECT    5
+#define SYSCALL_OPENAT      6
+#define SYSCALL_CLOSE       7
+#define SYSCALL_READ        8
+#define SYSCALL_WRITE       9
+#define SYSCALL_SEEK        10
+#define SYSCALL_IOCTL       11
+#define SYSCALL_DUP         12
+#define SYSCALL_DUP2        13
+#define SYSCALL_GETTID      14
+#define SYSCALL_GETPID      15
+#define SYSCALL_GETPPID     16
+#define SYSCALL_GETPGID     17
+#define SYSCALL_SETPGID     18
+#define SYSCALL_SETSID      19
+#define SYSCALL_FORK        20
+#define SYSCALL_SIGACTION   21
+#define SYSCALL_SIGRETURN   22
+#define SYSCALL_KILL        23
+#define SYSCALL_SIGPROCMASK 24
+#define SYSCALL_EXECVE      25
+#define SYSCALL_WAITPID     26
+#define SYSCALL_GETDENTS    27
+#define SYSCALL_CHDIR       28
+#define SYSCALL_FCHDIR      29
+#define SYSCALL_GETRESUID   30
+#define SYSCALL_GETRESGID   31
+#define SYSCALL_SETRESUID   32
+#define SYSCALL_SETRESGID   33
+#define SYSCALL_YIELD       34
+#define SYSCALL_GETCWD      35
+#define SYSCALL_FCNTL       36
+#define SYSCALL_STAT        37
+#define SYSCALL_ACCESS      38
+#define SYSCALL_READLINK    39
+#define SYSCALL_UNAME       40
+#define SYSCALL_PIPE        41
+#define SYSCALL_UNLINK      42
+#define SYSCALL_PPOLL       43
+#define SYSCALL_FUTEX       44
+#define SYSCALL_NEWTHREAD   45
+#define SYSCALL_EXITTHREAD  46
+#define SYSCALL_MKNODAT     47
+#define SYSCALL_CLOCK       48
+#define SYSCALL_CHMOD       49
+#define SYSCALL_CHOWN       50
+#define SYSCALL_UMASK       51
+#define SYSCALL_SLEEP       52
+#define SYSCALL_SETHOSTNAME 53
+#define SYSCALL_SIGALTSTACK 54
+#define SYSCALL_FTRUNCATE   55
+#define SYSCALL_SYNC        56
+#define SYSCALL_FSYNC       57
+#define SYSCALL_SIGPENDING  58
+#define SYSCALL_GETITIMER   59
+#define SYSCALL_SETITIMER   60
+#define SYSCALL_MSYNC       61
+#define SYSCALL_MOUNT       62
+#define SYSCALL_UMOUNT      63
+#define SYSCALL_RENAME      64
+#define SYSCALL_SYMLINK     65
+#define SYSCALL_GETRANDOM   66
+#define SYSCALL_CHROOT      67
+#define SYSCALL_PIVOTROOT   68
+#define SYSCALL_GETRUSAGE   69
+
+#ifndef __MLIBC_ABI_ONLY
+
+#ifdef __cplusplus
+static uint64_t syscall(uint64_t func, uint64_t arg1 = 0, uint64_t arg2 = 0, uint64_t arg3 = 0, uint64_t arg4 = 0, uint64_t arg5 = 0, uint64_t arg6 = 0) {
+#else
+static inline uint64_t syscall(uint64_t func, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6) {
+#endif
+    register uint64_t r4 asm("r10") = arg4;
+    register uint64_t r5 asm("r8") = arg5;
+    register uint64_t r6 asm("r9") = arg6;
+
+    uint64_t ret = 0;
+
+    asm volatile("syscall"
+        : "=a"(ret)
+        : "a"(func), "D"(arg1), "S"(arg2), "d"(arg3), "r"(r4), "r"(r5), "r"(r6)
+        : "memory", "rcx", "r11"
+    );
+
+    return ret;
+}
+
+#endif /* __MLIBC_ABI_ONLY */
+
+#endif /* _NOMOS__SYSCALL_H_ */
diff -urN --no-dereference mlibc/sysdeps/nomos/include/sys/mount.h mlibc-nomos/sysdeps/nomos/include/sys/mount.h
--- mlibc/sysdeps/nomos/include/sys/mount.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/sys/mount.h	2025-12-08 14:38:15.126065478 +1300
@@ -0,0 +1,22 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MNT_FORCE 1  /* Force unmounting. */
+
+#ifndef __MLIBC_ABI_ONLY
+
+int mount(const char *__source, const char *__target, const char *__filesystemtype, unsigned long __mountflags, const void *__data);
+int umount(const char *__target);
+int umount2(const char *__target, int __flags);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_MOUNT_H */
\ No newline at end of file
diff -urN --no-dereference mlibc/sysdeps/nomos/include/sys/reboot.h mlibc-nomos/sysdeps/nomos/include/sys/reboot.h
--- mlibc/sysdeps/nomos/include/sys/reboot.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/sys/reboot.h	2025-12-29 16:53:36.010869389 +1300
@@ -0,0 +1,16 @@
+#ifndef _SYS_REBOOT_H
+#define _SYS_REBOOT_H
+
+#include <abi-bits/reboot.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int reboot(int arg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_REBOOT_H */
\ No newline at end of file
diff -urN --no-dereference mlibc/sysdeps/nomos/include/sys/sysmacros.h mlibc-nomos/sysdeps/nomos/include/sys/sysmacros.h
--- mlibc/sysdeps/nomos/include/sys/sysmacros.h	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/include/sys/sysmacros.h	2025-12-14 21:33:14.009127404 +1300
@@ -0,0 +1,36 @@
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define majorhi 0xffffffff00000000ull
+#define majorlo 0x000000000000ff00ull
+#define minorhi 0x00000000ffff0000ull
+#define minorlo 0x00000000000000ffull
+
+static unsigned int __mlibc_dev_major(unsigned long long int __dev) {
+    return (unsigned int)(((__dev & majorhi) >> 32) | ((__dev & majorlo) >> 8));
+}
+
+static unsigned int __mlibc_dev_minor(unsigned long long int __dev) {
+    return (unsigned int)(((__dev & minorhi) >> 16) | (__dev & minorlo));
+}
+
+static unsigned long long int __mlibc_dev_makedev(unsigned int __major, unsigned int __minor) {
+    return (((unsigned long long int)(__major & 0xffffffff) << 32) |
+            (((unsigned long long int)(__minor & 0xffff)) << 16) |
+            (((unsigned long long int)(__major & 0xff00)) << 8) |
+            ((unsigned long long int)(__minor & 0xff)));
+}
+
+#define major(dev) __mlibc_dev_major(dev)
+#define minor(dev) __mlibc_dev_minor(dev)
+#define makedev(major, minor) __mlibc_dev_makedev(major, minor)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff -urN --no-dereference mlibc/sysdeps/nomos/meson.build mlibc-nomos/sysdeps/nomos/meson.build
--- mlibc/sysdeps/nomos/meson.build	1970-01-01 12:00:00.000000000 +1200
+++ mlibc-nomos/sysdeps/nomos/meson.build	2026-01-21 19:18:56.684975377 +1300
@@ -0,0 +1,137 @@
+sysdep_supported_options = {
+  'posix': true,
+  'linux': true,
+  'glibc': true,
+  'bsd': true,
+}
+
+rtld_sources += files(
+  'generic/generic.cpp'
+)
+
+libc_sources += files(
+  'generic/entry.cpp',
+  'generic/generic.cpp',
+  'generic/thread.S'
+)
+
+if not no_headers
+  install_headers(
+    'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/statx.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/reboot.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/limits.h',
+		'include/abi-bits/utsname.h',
+		'include/abi-bits/ptrace.h',
+		'include/abi-bits/vt.h',
+		'include/abi-bits/ptrace.h',
+		'include/abi-bits/poll.h',
+		'include/abi-bits/epoll.h',
+		'include/abi-bits/packet.h',
+		'include/abi-bits/inotify.h',
+		'include/abi-bits/clockid_t.h',
+		'include/abi-bits/ipc.h',
+		'include/abi-bits/shm.h',
+		'include/abi-bits/mqueue.h',
+		'include/abi-bits/suseconds_t.h',
+		'include/abi-bits/fsfilcnt_t.h',
+		'include/abi-bits/fsblkcnt_t.h',
+		'include/abi-bits/socklen_t.h',
+		'include/abi-bits/statvfs.h',
+		'include/abi-bits/ioctls.h',
+		'include/abi-bits/xattr.h',
+		'include/abi-bits/msg.h',
+		'include/abi-bits/random.h',
+		'include/abi-bits/rlim_t.h',
+		'include/abi-bits/sigval.h',
+		'include/abi-bits/sigevent.h',
+		'include/abi-bits/utmpx.h',
+		'include/abi-bits/utmp-defines.h',
+		'include/abi-bits/fd_set.h',
+		'include/abi-bits/sem.h',
+		'include/abi-bits/route.h',
+		'include/abi-bits/sa_family_t.h',
+		'include/abi-bits/sockaddr_storage.h',
+		'include/abi-bits/sig-limits.h',
+    subdir: 'abi-bits',
+    follow_symlinks: true
+  )
+  install_headers(
+    'include/asm/ioctls.h',
+    subdir: 'asm'
+  )
+  install_headers(
+    'include/sys/mount.h',
+	'include/sys/sysmacros.h',
+	'include/sys/reboot.h',
+    subdir: 'sys'
+  )
+  install_headers(
+	'include/linux/fb.h',
+	subdir: 'linux'
+  )
+  install_headers(
+	'include/nomos/syscall.h',
+	subdir: 'nomos'
+  )
+endif
+
+if not headers_only
+  crt = custom_target(
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: files('crt-' + host_machine.cpu_family() / 'crt1.S'),
+		output: 'crt1.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	crt_pie = custom_target(
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: files('crt-' + host_machine.cpu_family() / 'Scrt1.S'),
+		output: 'Scrt1.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target(
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: files('crt-' + host_machine.cpu_family() / 'crti.S'),
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target(
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: files('crt-' + host_machine.cpu_family() / 'crtn.S'),
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
