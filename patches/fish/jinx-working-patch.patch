diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/builtin_fg.cpp fish-3.0.2-workdir/src/builtin_fg.cpp
--- fish-3.0.2-clean/src/builtin_fg.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/builtin_fg.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -98,7 +98,7 @@
     } else {
         // If we aren't redirecting, send output to real stderr, since stuff in sb_err won't get
         // printed until the command finishes.
-        fwprintf(stderr, FG_MSG, j->job_id, j->command_wcstr());
+        fish_fwprintf_impl(stderr, FG_MSG, j->job_id, j->command_wcstr());
     }
 
     const wcstring ft = tok_first(j->command());
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/builtin_history.cpp fish-3.0.2-workdir/src/builtin_history.cpp
--- fish-3.0.2-clean/src/builtin_history.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/builtin_history.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -66,7 +66,7 @@
         wchar_t err_text[1024];
         const wchar_t *subcmd_str1 = enum_to_str(*hist_cmd, hist_enum_map);
         const wchar_t *subcmd_str2 = enum_to_str(sub_cmd, hist_enum_map);
-        swprintf(err_text, sizeof(err_text) / sizeof(wchar_t),
+        fish_swprintf_impl(err_text, sizeof(err_text) / sizeof(wchar_t),
                  _(L"you cannot do both '%ls' and '%ls' in the same invocation"), subcmd_str1,
                  subcmd_str2);
         streams.err.append_format(BUILTIN_ERR_COMBO2, cmd, err_text);
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/builtin_status.cpp fish-3.0.2-workdir/src/builtin_status.cpp
--- fish-3.0.2-clean/src/builtin_status.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/builtin_status.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -127,7 +127,7 @@
         wchar_t err_text[1024];
         const wchar_t *subcmd_str1 = enum_to_str(opts.status_cmd, status_enum_map);
         const wchar_t *subcmd_str2 = enum_to_str(sub_cmd, status_enum_map);
-        swprintf(err_text, sizeof(err_text) / sizeof(wchar_t),
+        fish_swprintf_impl(err_text, sizeof(err_text) / sizeof(wchar_t),
                  _(L"you cannot do both '%ls' and '%ls' in the same invocation"), subcmd_str1,
                  subcmd_str2);
         streams.err.append_format(BUILTIN_ERR_COMBO2, cmd, err_text);
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/common.cpp fish-3.0.2-workdir/src/common.cpp
--- fish-3.0.2-clean/src/common.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/common.cpp	2025-12-09 02:50:31.399753797 +1300
@@ -165,12 +165,12 @@
             int status = -1;
             if (info.dli_sname[0] == '_')
                 demangled = abi::__cxa_demangle(info.dli_sname, NULL, 0, &status);
-            swprintf(text, sizeof(text) / sizeof(wchar_t), L"%-3d %s + %td", i - skip_levels,
+            fish_swprintf_impl(text, sizeof(text) / sizeof(wchar_t), L"%-3d %s + %td", i - skip_levels,
                      status == 0 ? demangled : info.dli_sname == 0 ? symbols[i] : info.dli_sname,
                      (char *)callstack[i] - (char *)info.dli_saddr);
             free(demangled);
         } else {
-            swprintf(text, sizeof(text) / sizeof(wchar_t), L"%-3d %s", i - skip_levels, symbols[i]);
+            fish_swprintf_impl(text, sizeof(text) / sizeof(wchar_t), L"%-3d %s", i - skip_levels, symbols[i]);
         }
         backtrace_text.push_back(text);
     }
@@ -210,7 +210,7 @@
     while (1) {
         errno = 0;
 
-        c = fgetwc(f);
+        c = fish_fgetwc_impl(f);
         if (errno == EILSEQ || errno == EINTR) {
             continue;
         }
@@ -443,6 +443,122 @@
     return wcrtomb(converted, wc, &state) != (size_t)-1;
 }
 
+/// Helper function to convert wide character to narrow character for stdio functions.
+int wctomb_check(wchar_t wc) {
+    char converted[MB_LEN_MAX];
+    mbstate_t state = {};
+    size_t len = wcrtomb(converted, wc, &state);
+    if (len == (size_t)-1) {
+        return '?';
+    }
+    return converted[0];
+}
+
+/// Narrow-based swprintf replacement
+int fish_swprintf_impl(wchar_t *buf, size_t size, const wchar_t *format, ...) {
+    va_list ap;
+    va_start(ap, format);
+    int result = fish_vswprintf_impl(buf, size, format, ap);
+    va_end(ap);
+    return result;
+}
+
+/// Narrow-based vswprintf replacement
+int fish_vswprintf_impl(wchar_t *buf, size_t size, const wchar_t *format, va_list ap) {
+    if (!buf || size == 0) return -1;
+
+    // Convert format string from wide to narrow
+    std::string narrow_format = wcs2string(format);
+
+    // Create a temporary narrow buffer (larger to account for multibyte sequences)
+    size_t nbuf_size = size * MB_CUR_MAX + 1;
+    std::vector<char> nbuf(nbuf_size);
+    int result = vsnprintf(nbuf.data(), nbuf_size, narrow_format.c_str(), ap);
+
+    // Convert result back to wide string
+    if (result >= 0) {
+        wcstring wide_result = str2wcstring(nbuf.data());
+        size_t copy_len = std::min(wide_result.length(), size - 1);
+        wcsncpy(buf, wide_result.c_str(), copy_len);
+        buf[copy_len] = L'\0';
+        return copy_len;
+    }
+
+    return result;
+}
+
+/// Narrow-based fwprintf replacement
+int fish_fwprintf_impl(FILE *stream, const wchar_t *format, ...) {
+    va_list ap;
+    va_start(ap, format);
+    int result = fish_vfwprintf_impl(stream, format, ap);
+    va_end(ap);
+    return result;
+}
+
+/// Narrow-based vfwprintf replacement
+int fish_vfwprintf_impl(FILE *stream, const wchar_t *format, va_list ap) {
+    // Convert format string from wide to narrow
+    std::string narrow_format = wcs2string(format);
+
+    // Use vfprintf with the narrow format
+    return vfprintf(stream, narrow_format.c_str(), ap);
+}
+
+/// Narrow-based fputws replacement
+int fish_fputws_impl(const wchar_t *ws, FILE *stream) {
+    if (!ws) return EOF;
+    std::string narrow = wcs2string(ws);
+    return fputs(narrow.c_str(), stream);
+}
+
+/// Narrow-based fputwc replacement
+int fish_fputwc_impl(wchar_t wc, FILE *stream) {
+    char converted[MB_LEN_MAX];
+    mbstate_t state = {};
+    memset(&state, 0, sizeof(state));
+    size_t len = wcrtomb(converted, wc, &state);
+    if (len == (size_t)-1) {
+        return fputc('?', stream);
+    }
+    for (size_t i = 0; i < len; i++) {
+        if (fputc(converted[i], stream) == EOF) {
+            return EOF;
+        }
+    }
+    return (unsigned char)converted[0];
+}
+
+/// Narrow-based fgetwc replacement
+wint_t fish_fgetwc_impl(FILE *stream) {
+    char c = fgetc(stream);
+    if (c == EOF) return WEOF;
+
+    mbstate_t state = {};
+    memset(&state, 0, sizeof(state));
+    wchar_t wc;
+    char buf[MB_LEN_MAX];
+    buf[0] = c;
+
+    size_t len = mbrtowc(&wc, buf, 1, &state);
+    if (len == (size_t)-2) {
+        // Incomplete multibyte sequence, read more bytes
+        size_t i = 1;
+        while (i < MB_LEN_MAX) {
+            int next = fgetc(stream);
+            if (next == EOF) return WEOF;
+            buf[i++] = next;
+            len = mbrtowc(&wc, buf, i, &state);
+            if (len != (size_t)-2) break;
+        }
+    }
+
+    if (len == (size_t)-1 || len == 0) {
+        return (wint_t)(unsigned char)c;
+    }
+    return wc;
+}
+
 wcstring format_string(const wchar_t *format, ...) {
     va_list va;
     va_start(va, format);
@@ -484,7 +600,7 @@
         // Try printing.
         va_list va;
         va_copy(va, va_orig);
-        status = vswprintf(buff, size / sizeof(wchar_t), format, va);
+        status = fish_vswprintf_impl(buff, size / sizeof(wchar_t), format, va);
         va_end(va);
     }
 
@@ -610,9 +726,9 @@
     pid_t current_pid = getpid();
 
     if (current_pid == initial_pid) {
-        fwprintf(stderr, L"<%lc> %ls: %ls\n", (unsigned long)level, program_name, msg.c_str());
+        fish_fwprintf_impl(stderr, L"<%lc> %ls: %ls\n", (unsigned long)level, program_name, msg.c_str());
     } else {
-        fwprintf(stderr, L"<%lc> %ls: %d: %ls\n", (unsigned long)level, program_name, current_pid,
+        fish_fwprintf_impl(stderr, L"<%lc> %ls: %d: %ls\n", (unsigned long)level, program_name, current_pid,
                  msg.c_str());
     }
 }
@@ -831,7 +947,7 @@
         } else {
             // All other chars need to have their UTF-8 representation encoded in hex.
             wchar_t buf[4];
-            swprintf(buf, sizeof buf / sizeof buf[0], L"%%%02X", c2);
+            fish_swprintf_impl(buf, sizeof buf / sizeof buf[0], L"%%%02X", c2);
             out.append(buf);
         }
     }
@@ -890,7 +1006,7 @@
         } else {
             // All other chars need to have their UTF-8 representation encoded in hex.
             wchar_t buf[4];
-            swprintf(buf, sizeof buf / sizeof buf[0], L"_%02X", c2);
+            fish_swprintf_impl(buf, sizeof buf / sizeof buf[0], L"_%02X", c2);
             out.append(buf);
             prev_was_hex_encoded = true;
         }
@@ -1758,11 +1874,11 @@
     wchar_t buf[64];
 
     auto cols = env_get(L"COLUMNS", ENV_EXPORT);
-    swprintf(buf, 64, L"%d", (int)new_termsize->ws_col);
+    fish_swprintf_impl(buf, 64, L"%d", (int)new_termsize->ws_col);
     env_set_one(L"COLUMNS", ENV_GLOBAL | (cols.missing_or_empty() ? ENV_DEFAULT : ENV_EXPORT), buf);
 
     auto lines = env_get(L"LINES", ENV_EXPORT);
-    swprintf(buf, 64, L"%d", (int)new_termsize->ws_row);
+    fish_swprintf_impl(buf, 64, L"%d", (int)new_termsize->ws_row);
     env_set_one(L"LINES", ENV_GLOBAL | (lines.missing_or_empty() ? ENV_DEFAULT : ENV_EXPORT), buf);
 
 #ifdef HAVE_WINSIZE
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/common.h fish-3.0.2-workdir/src/common.h
--- fish-3.0.2-clean/src/common.h	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/common.h	2025-12-09 02:50:31.398944155 +1300
@@ -344,6 +344,34 @@
 char *wcs2str(const wcstring &in);
 std::string wcs2string(const wcstring &input);
 
+/// Helper function to convert wide character to narrow character for stdio functions.
+int wctomb_check(wchar_t wc);
+
+/// Narrow-based replacements for wide stdio functions
+
+// For swprintf replacement - write formatted wide string using narrow snprintf
+#define FISH_SWPRINTF(buf, size, ...) fish_swprintf_impl((buf), (size), __VA_ARGS__)
+int fish_swprintf_impl(wchar_t *buf, size_t size, const wchar_t *format, ...);
+
+// For fwprintf replacement - write formatted output to stream
+#define FISH_FWPRINTF(stream, ...) fish_fwprintf_impl((stream), __VA_ARGS__)
+int fish_fwprintf_impl(FILE *stream, const wchar_t *format, ...);
+
+// For vfwprintf replacement
+int fish_vfwprintf_impl(FILE *stream, const wchar_t *format, va_list ap);
+
+// For vswprintf replacement
+int fish_vswprintf_impl(wchar_t *buf, size_t size, const wchar_t *format, va_list ap);
+
+// For fputws replacement
+int fish_fputws_impl(const wchar_t *ws, FILE *stream);
+
+// For fputwc replacement
+int fish_fputwc_impl(wchar_t wc, FILE *stream);
+
+// For fgetwc replacement
+wint_t fish_fgetwc_impl(FILE *stream);
+
 /// Test if a string prefixes another. Returns true if a is a prefix of b.
 bool string_prefixes_string(const wcstring &proposed_prefix, const wcstring &value);
 bool string_prefixes_string(const wchar_t *proposed_prefix, const wcstring &value);
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/event.cpp fish-3.0.2-workdir/src/event.cpp
--- fish-3.0.2-clean/src/event.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/event.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -164,11 +164,11 @@
 
 #if 0
 static void show_all_handlers(void) {
-    fwprintf(stdout, L"event handlers:\n");
+    fish_fwprintf_impl(stdout, L"event handlers:\n");
     for (event_list_t::const_iterator iter = events.begin(); iter != events.end(); ++iter) {
         const event_t *foo = *iter;
         wcstring tmp = event_get_desc(foo);
-        fwprintf(stdout, L"    handler now %ls\n", tmp.c_str());
+        fish_fwprintf_impl(stdout, L"    handler now %ls\n", tmp.c_str());
     }
 }
 #endif
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/fish.cpp fish-3.0.2-workdir/src/fish.cpp
--- fish-3.0.2-clean/src/fish.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/fish.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -255,7 +255,7 @@
                 if (tmp >= 0 && tmp <= 10 && !*end && !errno) {
                     debug_level = (int)tmp;
                 } else {
-                    fwprintf(stderr, _(L"Invalid value '%s' for debug-level flag"), optarg);
+                    fish_fwprintf_impl(stderr, _(L"Invalid value '%s' for debug-level flag"), optarg);
                     exit(1);
                 }
                 break;
@@ -290,7 +290,7 @@
                 break;
             }
             case 'v': {
-                fwprintf(stdout, _(L"%s, version %s\n"), PACKAGE_NAME, get_fish_version());
+                fish_fwprintf_impl(stdout, _(L"%s, version %s\n"), PACKAGE_NAME, get_fish_version());
                 exit(0);
                 break;
             }
@@ -304,7 +304,7 @@
                 if (tmp > 0 && tmp <= 128 && !*end && !errno) {
                     debug_stack_frames = (int)tmp;
                 } else {
-                    fwprintf(stderr, _(L"Invalid value '%s' for debug-stack-frames flag"), optarg);
+                    fish_fwprintf_impl(stderr, _(L"Invalid value '%s' for debug-stack-frames flag"), optarg);
                     exit(1);
                 }
                 break;
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/fish_indent.cpp fish-3.0.2-workdir/src/fish_indent.cpp
--- fish-3.0.2-clean/src/fish_indent.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/fish_indent.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -52,7 +52,7 @@
 static wcstring read_file(FILE *f) {
     wcstring result;
     while (1) {
-        wint_t c = fgetwc(f);
+        wint_t c = fish_fgetwc_impl(f);
         if (c == WEOF) {
             if (ferror(f)) {
                 wperror(L"fgetwc");
@@ -144,7 +144,7 @@
         nextc_str[1] = L'c';
         nextc_str[2] = nextc + '@';
     }
-    fwprintf(stderr, L"{off %4u, len %4u, indent %2u, kw %ls, %ls} [%ls|%ls|%ls]\n",
+    fish_fwprintf_impl(stderr, L"{off %4u, len %4u, indent %2u, kw %ls, %ls} [%ls|%ls|%ls]\n",
              node.source_start, node.source_length, node_indent, keyword_description(node.keyword),
              token_type_description(node.type), prevc_str, source_txt.c_str(), nextc_str);
 }
@@ -225,7 +225,7 @@
 
     if (dump_parse_tree) {
         const wcstring dump = parse_dump_tree(parse_tree, src);
-        fwprintf(stderr, L"%ls\n", dump.c_str());
+        fish_fwprintf_impl(stderr, L"%ls\n", dump.c_str());
     }
 
     // We may have a forest of disconnected trees on a parse failure. We have to handle all nodes
@@ -428,7 +428,7 @@
                 break;
             }
             case 'v': {
-                fwprintf(stderr, _(L"%ls, version %s\n"), program_name, get_fish_version());
+                fish_fwprintf_impl(stderr, _(L"%ls, version %s\n"), program_name, get_fish_version());
                 exit(0);
                 break;
             }
@@ -458,7 +458,7 @@
                 if (tmp >= 0 && tmp <= 10 && !*end && !errno) {
                     debug_level = (int)tmp;
                 } else {
-                    fwprintf(stderr, _(L"Invalid value '%s' for debug-level flag"), optarg);
+                    fish_fwprintf_impl(stderr, _(L"Invalid value '%s' for debug-level flag"), optarg);
                     exit(1);
                 }
                 break;
@@ -473,7 +473,7 @@
                 if (tmp > 0 && tmp <= 128 && !*end && !errno) {
                     debug_stack_frames = (int)tmp;
                 } else {
-                    fwprintf(stderr, _(L"Invalid value '%s' for debug-stack-frames flag"), optarg);
+                    fish_fwprintf_impl(stderr, _(L"Invalid value '%s' for debug-stack-frames flag"), optarg);
                     exit(1);
                 }
                 break;
@@ -492,7 +492,7 @@
     wcstring src;
     if (argc == 0) {
         if (output_type == output_type_file) {
-            fwprintf(stderr, _(L"Expected file path to read/write for -w:\n\n $ %ls -w foo.fish\n"),
+            fish_fwprintf_impl(stderr, _(L"Expected file path to read/write for -w:\n\n $ %ls -w foo.fish\n"),
                      program_name);
             exit(1);
         }
@@ -504,11 +504,11 @@
             fclose(fh);
             output_location = *argv;
         } else {
-            fwprintf(stderr, _(L"Opening \"%s\" failed: %s\n"), *argv, strerror(errno));
+            fish_fwprintf_impl(stderr, _(L"Opening \"%s\" failed: %s\n"), *argv, strerror(errno));
             exit(1);
         }
     } else {
-        fwprintf(stderr, _(L"Too many arguments\n"));
+        fish_fwprintf_impl(stderr, _(L"Too many arguments\n"));
         exit(1);
     }
 
@@ -530,11 +530,11 @@
         case output_type_file: {
             FILE *fh = fopen(output_location, "w");
             if (fh) {
-                fputws(output_wtext.c_str(), fh);
+                fish_fputws_impl(output_wtext.c_str(), fh);
                 fclose(fh);
                 exit(0);
             } else {
-                fwprintf(stderr, _(L"Opening \"%s\" failed: %s\n"), output_location,
+                fish_fwprintf_impl(stderr, _(L"Opening \"%s\" failed: %s\n"), output_location,
                          strerror(errno));
                 exit(1);
             }
@@ -550,6 +550,6 @@
         }
     }
 
-    fputws(str2wcstring(colored_output).c_str(), stdout);
+    fish_fputws_impl(str2wcstring(colored_output).c_str(), stdout);
     return 0;
 }
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/fish_key_reader.cpp fish-3.0.2-workdir/src/fish_key_reader.cpp
--- fish-3.0.2-clean/src/fish_key_reader.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/fish_key_reader.cpp	2025-12-09 02:50:31.399975491 +1300
@@ -54,12 +54,12 @@
     recent_chars[3] = c;
     if (c == shell_modes.c_cc[VINTR]) {
         if (recent_chars[2] == shell_modes.c_cc[VINTR]) return true;
-        fwprintf(stderr, L"Press [ctrl-%c] again to exit\n", shell_modes.c_cc[VINTR] + 0x40);
+        fish_fwprintf_impl(stderr, L"Press [ctrl-%c] again to exit\n", shell_modes.c_cc[VINTR] + 0x40);
         return false;
     }
     if (c == shell_modes.c_cc[VEOF]) {
         if (recent_chars[2] == shell_modes.c_cc[VEOF]) return true;
-        fwprintf(stderr, L"Press [ctrl-%c] again to exit\n", shell_modes.c_cc[VEOF] + 0x40);
+        fish_fwprintf_impl(stderr, L"Press [ctrl-%c] again to exit\n", shell_modes.c_cc[VEOF] + 0x40);
         return false;
     }
     return memcmp(recent_chars, "exit", 4) == 0 || memcmp(recent_chars, "quit", 4) == 0;
@@ -98,36 +98,36 @@
 static void ctrl_to_symbol(wchar_t *buf, int buf_len, wchar_t wc, bool bind_friendly) {
     if (ctrl_symbolic_names[wc]) {
         if (bind_friendly) {
-            swprintf(buf, buf_len, L"%ls", ctrl_symbolic_names[wc]);
+            fish_swprintf_impl(buf, buf_len, L"%ls", ctrl_symbolic_names[wc]);
         } else {
-            swprintf(buf, buf_len, L"\\c%c  (or %ls)", wc + 0x40, ctrl_symbolic_names[wc]);
+            fish_swprintf_impl(buf, buf_len, L"\\c%c  (or %ls)", wc + 0x40, ctrl_symbolic_names[wc]);
         }
     } else {
-        swprintf(buf, buf_len, L"\\c%c", wc + 0x40);
+        fish_swprintf_impl(buf, buf_len, L"\\c%c", wc + 0x40);
     }
 }
 
 static void space_to_symbol(wchar_t *buf, int buf_len, wchar_t wc, bool bind_friendly) {
     if (bind_friendly) {
-        swprintf(buf, buf_len, L"\\x%X", wc);
+        fish_swprintf_impl(buf, buf_len, L"\\x%X", wc);
     } else {
-        swprintf(buf, buf_len, L"\\x%X  (aka \"space\")", wc);
+        fish_swprintf_impl(buf, buf_len, L"\\x%X  (aka \"space\")", wc);
     }
 }
 
 static void del_to_symbol(wchar_t *buf, int buf_len, wchar_t wc, bool bind_friendly) {
     if (bind_friendly) {
-        swprintf(buf, buf_len, L"\\x%X", wc);
+        fish_swprintf_impl(buf, buf_len, L"\\x%X", wc);
     } else {
-        swprintf(buf, buf_len, L"\\x%X  (aka \"del\")", wc);
+        fish_swprintf_impl(buf, buf_len, L"\\x%X  (aka \"del\")", wc);
     }
 }
 
 static void ascii_printable_to_symbol(wchar_t *buf, int buf_len, wchar_t wc, bool bind_friendly) {
     if (bind_friendly && must_escape(wc)) {
-        swprintf(buf, buf_len, L"\\%c", wc);
+        fish_swprintf_impl(buf, buf_len, L"\\%c", wc);
     } else {
-        swprintf(buf, buf_len, L"%c", wc);
+        fish_swprintf_impl(buf, buf_len, L"%c", wc);
     }
 }
 
@@ -145,9 +145,9 @@
     } else if (wc < 0x80) {  // ASCII characters that are not control characters
         ascii_printable_to_symbol(buf, sizeof(buf) / sizeof(*buf), wc, bind_friendly);
     } else if (wc <= 0xFFFF) {  // BMP Unicode chararacter
-        swprintf(buf, sizeof(buf) / sizeof(*buf), L"\\u%04X", wc);
+        fish_swprintf_impl(buf, sizeof(buf) / sizeof(*buf), L"\\u%04X", wc);
     } else {  // Non-BMP Unicode chararacter
-        swprintf(buf, sizeof(buf) / sizeof(*buf), L"\\U%06X", wc);
+        fish_swprintf_impl(buf, sizeof(buf) / sizeof(*buf), L"\\U%06X", wc);
     }
 
     return buf;
@@ -159,23 +159,23 @@
 
 static void output_bind_command(std::vector<wchar_t> &bind_chars) {
     if (bind_chars.size()) {
-        fputws(L"bind ", stdout);
+        fish_fputws_impl(L"bind ", stdout);
         for (size_t i = 0; i < bind_chars.size(); i++) {
-            fputws(char_to_symbol(bind_chars[i], true), stdout);
+            fish_fputws_impl(char_to_symbol(bind_chars[i], true), stdout);
         }
-        fputws(L" 'do something'\n", stdout);
+        fish_fputws_impl(L" 'do something'\n", stdout);
         bind_chars.clear();
     }
 }
 
 static void output_info_about_char(wchar_t wc) {
-    fwprintf(stderr, L"hex: %4X  char: %ls\n", wc, char_to_symbol(wc, false));
+    fish_fwprintf_impl(stderr, L"hex: %4X  char: %ls\n", wc, char_to_symbol(wc, false));
 }
 
 static bool output_matching_key_name(wchar_t wc) {
     char *name = sequence_name(wc);
     if (name) {
-        fwprintf(stdout, L"bind -k %s 'do something'\n", name);
+        fish_fwprintf_impl(stdout, L"bind -k %s 'do something'\n", name);
         free(name);
         return true;
     }
@@ -187,11 +187,11 @@
     double now = timef();
     long long int delta_tstamp_us = 1000000 * (now - prev_tstamp);
 
-    if (delta_tstamp_us >= 200000 && first_char_seen) fputwc(L'\n', stderr);
+    if (delta_tstamp_us >= 200000 && first_char_seen) fish_fputwc_impl(L'\n', stderr);
     if (delta_tstamp_us >= 1000000) {
-        fwprintf(stderr, L"              ");
+        fish_fwprintf_impl(stderr, L"              ");
     } else {
-        fwprintf(stderr, L"(%3lld.%03lld ms)  ", delta_tstamp_us / 1000, delta_tstamp_us % 1000);
+        fish_fwprintf_impl(stderr, L"(%3lld.%03lld ms)  ", delta_tstamp_us / 1000, delta_tstamp_us % 1000);
     }
     return now;
 }
@@ -202,7 +202,7 @@
     double prev_tstamp = 0.0;
     std::vector<wchar_t> bind_chars;
 
-    fwprintf(stderr, L"Press a key\n\n");
+    fish_fwprintf_impl(stderr, L"Press a key\n\n");
     while (keep_running) {
         wchar_t wc;
         if (reader_interrupted()) {
@@ -226,7 +226,7 @@
         }
 
         if (should_exit(wc)) {
-            fwprintf(stderr, L"\nExiting at your request.\n");
+            fish_fwprintf_impl(stderr, L"\nExiting at your request.\n");
             break;
         }
 
@@ -238,7 +238,7 @@
 /// Otherwise just report receipt of the signal.
 static struct sigaction old_sigactions[32];
 static void signal_handler(int signo, siginfo_t *siginfo, void *siginfo_arg) {
-    fwprintf(stdout, _(L"signal #%d (%ls) received\n"), signo, sig2wcs(signo));
+    fish_fwprintf_impl(stdout, _(L"signal #%d (%ls) received\n"), signo, sig2wcs(signo));
     if (signo == SIGHUP || signo == SIGTERM || signo == SIGABRT || signo == SIGSEGV) {
         keep_running = false;
     }
@@ -288,11 +288,11 @@
     install_our_signal_handlers();
 
     if (continuous_mode) {
-        fwprintf(stderr, L"\n");
-        fwprintf(stderr, L"To terminate this program type \"exit\" or \"quit\" in this window,\n");
-        fwprintf(stderr, L"or press [ctrl-%c] or [ctrl-%c] twice in a row.\n",
+        fish_fwprintf_impl(stderr, L"\n");
+        fish_fwprintf_impl(stderr, L"To terminate this program type \"exit\" or \"quit\" in this window,\n");
+        fish_fwprintf_impl(stderr, L"or press [ctrl-%c] or [ctrl-%c] twice in a row.\n",
                  shell_modes.c_cc[VINTR] + 0x40, shell_modes.c_cc[VEOF] + 0x40);
-        fwprintf(stderr, L"\n");
+        fish_fwprintf_impl(stderr, L"\n");
     }
 
     process_input(continuous_mode);
@@ -309,7 +309,7 @@
     if (tmp >= 0 && tmp <= 10 && !*end && !errno) {
         debug_level = (int)tmp;
     } else {
-        fwprintf(stderr, _(L"Invalid value '%s' for debug-level flag\n"), optarg);
+        fish_fwprintf_impl(stderr, _(L"Invalid value '%s' for debug-level flag\n"), optarg);
         return false;
     }
 
@@ -323,7 +323,7 @@
     if (tmp > 0 && tmp <= 128 && !*end && !errno) {
         debug_stack_frames = (int)tmp;
     } else {
-        fwprintf(stderr, _(L"Invalid value '%s' for debug-stack-frames flag\n"), optarg);
+        fish_fwprintf_impl(stderr, _(L"Invalid value '%s' for debug-stack-frames flag\n"), optarg);
         return false;
     }
 
@@ -360,7 +360,7 @@
                 break;
             }
             case 'v': {
-                fwprintf(stdout, L"%s\n", get_fish_version());
+                fish_fwprintf_impl(stdout, L"%s\n", get_fish_version());
                 return false;
             }
             default: {
@@ -375,7 +375,7 @@
 
     argc -= optind;
     if (argc != 0) {
-        fwprintf(stderr, L"Expected no arguments, got %d\n", argc);
+        fish_fwprintf_impl(stderr, L"Expected no arguments, got %d\n", argc);
         return false;
     }
 
@@ -389,7 +389,7 @@
     if (!parse_flags(argc, argv, &continuous_mode)) return 1;
 
     if (!isatty(STDIN_FILENO)) {
-        fwprintf(stderr, L"Stdin must be attached to a tty.\n");
+        fish_fwprintf_impl(stderr, L"Stdin must be attached to a tty.\n");
         return 1;
     }
 
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/fish_tests.cpp fish-3.0.2-workdir/src/fish_tests.cpp
--- fish-3.0.2-clean/src/fish_tests.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/fish_tests.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -110,9 +110,9 @@
 static void say(const wchar_t *fmt, ...) {
     va_list va;
     va_start(va, fmt);
-    vfwprintf(stdout, fmt, va);
+    fish_vfwprintf_impl(stdout, fmt, va);
     va_end(va);
-    fwprintf(stdout, L"\n");
+    fish_fwprintf_impl(stdout, L"\n");
 }
 
 /// Print formatted error string.
@@ -126,18 +126,18 @@
 
     // Show errors in red.
     if (colorize) {
-        fputws(L"\x1B[31m", stdout);
+        fish_fputws_impl(L"\x1B[31m", stdout);
     }
-    fwprintf(stdout, L"Error: ");
-    vfwprintf(stdout, blah, va);
+    fish_fwprintf_impl(stdout, L"Error: ");
+    fish_vfwprintf_impl(stdout, blah, va);
     va_end(va);
 
     // Return to normal color.
     if (colorize) {
-        fputws(L"\x1B[0m", stdout);
+        fish_fputws_impl(L"\x1B[0m", stdout);
     }
 
-    fwprintf(stdout, L"\n");
+    fish_fwprintf_impl(stdout, L"\n");
 }
 
 /// Joins a wcstring_list_t via commas.
@@ -413,7 +413,7 @@
 
         wchar_t wbuf1[128], wbuf2[128];
         format_long_safe(wbuf1, j);
-        swprintf(wbuf2, 128, L"%d", j);
+        fish_swprintf_impl(wbuf2, 128, L"%d", j);
         do_test(!wcscmp(wbuf1, wbuf2));
     }
 
@@ -553,12 +553,12 @@
         while (t.next(&token)) {
             if (i >= sizeof types / sizeof *types) {
                 err(L"Too many tokens returned from tokenizer");
-                fwprintf(stdout, L"Got excess token type %ld\n", (long)token.type);
+                fish_fwprintf_impl(stdout, L"Got excess token type %ld\n", (long)token.type);
                 break;
             }
             if (types[i] != token.type) {
                 err(L"Tokenization error:");
-                fwprintf(stdout,
+                fish_fwprintf_impl(stdout,
                          L"Token number %zu of string \n'%ls'\n, expected type %ld, got token type "
                          L"%ld\n",
                          i + 1, str, (long)types[i], (long)token.type);
@@ -1960,10 +1960,10 @@
 
             wcstring text = sd.line(0).to_string();
             if (text != expected) {
-                fwprintf(stderr, L"width %zu got %zu<%ls>, expected %zu<%ls>\n", this->width,
+                fish_fwprintf_impl(stderr, L"width %zu got %zu<%ls>, expected %zu<%ls>\n", this->width,
                          text.length(), text.c_str(), expected.length(), expected.c_str());
                 for (size_t i = 0; i < std::max(text.length(), expected.length()); i++) {
-                    fwprintf(stderr, L"i %zu got <%lx> expected <%lx>\n", i,
+                    fish_fwprintf_impl(stderr, L"i %zu got <%lx> expected <%lx>\n", i,
                              i >= text.length() ? 0xffff : text[i],
                              i >= expected.length() ? 0xffff : expected[i]);
                 }
@@ -2554,7 +2554,7 @@
     wcstring result =
         completion_apply_to_command_line(completion, flags, line, &cursor_pos, append_only);
     if (result != expected) {
-        fwprintf(stderr, L"line %ld: %ls + %ls -> [%ls], expected [%ls]\n", source_line,
+        fish_fwprintf_impl(stderr, L"line %ld: %ls + %ls -> [%ls], expected [%ls]\n", source_line,
                  line.c_str(), completion.c_str(), result.c_str(), expected.c_str());
     }
     do_test(result == expected);
@@ -2598,12 +2598,12 @@
     bool expects_error = (expected == L"<error>");
 
     if (comps.empty() && !expects_error) {
-        fwprintf(stderr, L"line %ld: autosuggest_suggest_special() failed for command %ls\n", line,
+        fish_fwprintf_impl(stderr, L"line %ld: autosuggest_suggest_special() failed for command %ls\n", line,
                  command.c_str());
         do_test_from(!comps.empty(), line);
         return;
     } else if (!comps.empty() && expects_error) {
-        fwprintf(stderr,
+        fish_fwprintf_impl(stderr,
                  L"line %ld: autosuggest_suggest_special() was expected to fail but did not, "
                  L"for command %ls\n",
                  line, command.c_str());
@@ -2615,12 +2615,12 @@
         const completion_t &suggestion = comps.at(0);
 
         if (suggestion.completion != expected) {
-            fwprintf(
+            fish_fwprintf_impl(
                 stderr,
                 L"line %ld: complete() for cd returned the wrong expected string for command %ls\n",
                 line, command.c_str());
-            fwprintf(stderr, L"  actual: %ls\n", suggestion.completion.c_str());
-            fwprintf(stderr, L"expected: %ls\n", expected.c_str());
+            fish_fwprintf_impl(stderr, L"  actual: %ls\n", suggestion.completion.c_str());
+            fish_fwprintf_impl(stderr, L"expected: %ls\n", expected.c_str());
             do_test_from(suggestion.completion == expected, line);
         }
     }
@@ -2634,12 +2634,12 @@
     bool expects_error = (expected == L"<error>");
 
     if (comps.empty() && !expects_error) {
-        fwprintf(stderr, L"line %ld: autosuggest_suggest_special() failed for command %ls\n", line,
+        fish_fwprintf_impl(stderr, L"line %ld: autosuggest_suggest_special() failed for command %ls\n", line,
                  command.c_str());
         do_test_from(!comps.empty(), line);
         return;
     } else if (!comps.empty() && expects_error) {
-        fwprintf(stderr,
+        fish_fwprintf_impl(stderr,
                  L"line %ld: autosuggest_suggest_special() was expected to fail but did not, "
                  L"for command %ls\n",
                  line, command.c_str());
@@ -2651,12 +2651,12 @@
         const completion_t &suggestion = comps.at(0);
 
         if (suggestion.completion != expected) {
-            fwprintf(stderr,
+            fish_fwprintf_impl(stderr,
                      L"line %ld: complete() for cd tab completion returned the wrong expected "
                      L"string for command %ls\n",
                      line, command.c_str());
-            fwprintf(stderr, L"  actual: %ls\n", suggestion.completion.c_str());
-            fwprintf(stderr, L"expected: %ls\n", expected.c_str());
+            fish_fwprintf_impl(stderr, L"  actual: %ls\n", suggestion.completion.c_str());
+            fish_fwprintf_impl(stderr, L"expected: %ls\n", expected.c_str());
             do_test_from(suggestion.completion == expected, line);
         }
     }
@@ -2762,9 +2762,9 @@
     do_test(comps.empty());
     if (!comps.empty()) {
         const wcstring &suggestion = comps.front().completion;
-        fwprintf(stderr, L"line %ld: complete() expected to return nothing for %ls\n", line,
+        fish_fwprintf_impl(stderr, L"line %ld: complete() expected to return nothing for %ls\n", line,
                  command.c_str());
-        fwprintf(stderr, L"  instead got: %ls\n", suggestion.c_str());
+        fish_fwprintf_impl(stderr, L"  instead got: %ls\n", suggestion.c_str());
     }
 }
 
@@ -3706,7 +3706,7 @@
         if (stop >= end)
             break;
     }
-    fwprintf(stdout, L"%lu items - %.2f msec per item\n", (unsigned long)count,
+    fish_fwprintf_impl(stdout, L"%lu items - %.2f msec per item\n", (unsigned long)count,
              (stop - start) * 1E6 / count);
     hist->clear();
 }
@@ -3789,7 +3789,7 @@
     bool log_it = true;
     unsigned long max_len = 5;
     for (unsigned long len = 0; len < max_len; len++) {
-        if (log_it) fwprintf(stderr, L"%lu / %lu...", len, max_len);
+        if (log_it) fish_fwprintf_impl(stderr, L"%lu / %lu...", len, max_len);
 
         // We wish to look at all permutations of 4 elements of 'fuzzes' (with replacement).
         // Construct an int and keep incrementing it.
@@ -3798,7 +3798,7 @@
                                       &src)) {
             parse_tree_from_string(src, parse_flag_continue_after_error, &node_tree, &errors);
         }
-        if (log_it) fwprintf(stderr, L"done (%lu)\n", permutation);
+        if (log_it) fish_fwprintf_impl(stderr, L"done (%lu)\n", permutation);
     }
     double end = timef();
     if (log_it) say(L"All fuzzed in %f seconds!", end - start);
@@ -4952,7 +4952,7 @@
             exit(-1);
         }
         if (!strcmp(wd, "/")) {
-            fwprintf(stderr,
+            fish_fwprintf_impl(stderr,
                      L"Unable to find 'tests' directory, which should contain file test.fish\n");
             exit(EXIT_FAILURE);
         }
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/input_common.cpp fish-3.0.2-workdir/src/input_common.cpp
--- fish-3.0.2-clean/src/input_common.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/input_common.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -167,7 +167,7 @@
 
     long tmp = fish_wcstol(escape_time_ms->as_string().c_str());
     if (errno || tmp < 10 || tmp >= 5000) {
-        fwprintf(stderr,
+        fish_fwprintf_impl(stderr,
                  L"ignoring fish_escape_delay_ms: value '%ls' "
                  L"is not an integer or is < 10 or >= 5000 ms\n",
                  escape_time_ms->as_string().c_str());
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/io.cpp fish-3.0.2-workdir/src/io.cpp
--- fish-3.0.2-clean/src/io.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/io.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -15,19 +15,19 @@
 
 io_data_t::~io_data_t() = default;
 
-void io_close_t::print() const { fwprintf(stderr, L"close %d\n", fd); }
+void io_close_t::print() const { fish_fwprintf_impl(stderr, L"close %d\n", fd); }
 
-void io_fd_t::print() const { fwprintf(stderr, L"FD map %d -> %d\n", old_fd, fd); }
+void io_fd_t::print() const { fish_fwprintf_impl(stderr, L"FD map %d -> %d\n", old_fd, fd); }
 
-void io_file_t::print() const { fwprintf(stderr, L"file (%s)\n", filename_cstr); }
+void io_file_t::print() const { fish_fwprintf_impl(stderr, L"file (%s)\n", filename_cstr); }
 
 void io_pipe_t::print() const {
-    fwprintf(stderr, L"pipe {%d, %d} (input: %s)\n", pipe_fd[0], pipe_fd[1],
+    fish_fwprintf_impl(stderr, L"pipe {%d, %d} (input: %s)\n", pipe_fd[0], pipe_fd[1],
              is_input ? "yes" : "no");
 }
 
 void io_buffer_t::print() const {
-    fwprintf(stderr, L"buffer (input: %s, size %lu)\n",
+    fish_fwprintf_impl(stderr, L"buffer (input: %s, size %lu)\n",
              is_input ? "yes" : "no", (unsigned long)buffer_.size());
 }
 
@@ -142,21 +142,21 @@
 {
     if (chain.empty())
     {
-        fwprintf(stderr, L"Empty chain %p\n", &chain);
+        fish_fwprintf_impl(stderr, L"Empty chain %p\n", &chain);
         return;
     }
 
-    fwprintf(stderr, L"Chain %p (%ld items):\n", &chain, (long)chain.size());
+    fish_fwprintf_impl(stderr, L"Chain %p (%ld items):\n", &chain, (long)chain.size());
     for (size_t i=0; i < chain.size(); i++)
     {
         const shared_ptr<io_data_t> &io = chain.at(i);
         if (io.get() == NULL)
         {
-            fwprintf(stderr, L"\t(null)\n");
+            fish_fwprintf_impl(stderr, L"\t(null)\n");
         }
         else
         {
-            fwprintf(stderr, L"\t%lu: fd:%d, ", (unsigned long)i, io->fd);
+            fish_fwprintf_impl(stderr, L"\t%lu: fd:%d, ", (unsigned long)i, io->fd);
             io->print();
         }
     }
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/iothread.cpp fish-3.0.2-workdir/src/iothread.cpp
--- fish-3.0.2-clean/src/iothread.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/iothread.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -254,7 +254,7 @@
     }
 #if TIME_DRAIN
     double after = timef();
-    fwprintf(stdout, L"(Waited %.02f msec for %d thread(s) to drain)\n", 1000 * (after - now),
+    fish_fwprintf_impl(stdout, L"(Waited %.02f msec for %d thread(s) to drain)\n", 1000 * (after - now),
              thread_count);
 #endif
 }
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/output.cpp fish-3.0.2-workdir/src/output.cpp
--- fish-3.0.2-clean/src/output.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/output.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -542,7 +542,7 @@
 
 #if 0
     wcstring desc = result.description();
-    fwprintf(stdout, L"Parsed %ls from %ls (%s)\n", desc.c_str(), val.c_str(),
+    fish_fwprintf_impl(stdout, L"Parsed %ls from %ls (%s)\n", desc.c_str(), val.c_str(),
              is_background ? "background" : "foreground");
 #endif
 
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/parse_execution.cpp fish-3.0.2-workdir/src/parse_execution.cpp
--- fish-3.0.2-clean/src/parse_execution.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/parse_execution.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -626,7 +626,7 @@
 
         // Print it.
         if (!should_suppress_stderr_for_tests()) {
-            fwprintf(stderr, L"%ls", backtrace_and_desc.c_str());
+            fish_fwprintf_impl(stderr, L"%ls", backtrace_and_desc.c_str());
         }
     }
     return parse_execution_errored;
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/parser.cpp fish-3.0.2-workdir/src/parser.cpp
--- fish-3.0.2-clean/src/parser.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/parser.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -279,19 +279,19 @@
             continue;
         }
 
-        if (fwprintf(out, L"%d\t%d\t", my_time, me->parse + me->exec) < 0) {
+        if (fish_fwprintf_impl(out, L"%d\t%d\t", my_time, me->parse + me->exec) < 0) {
             wperror(L"fwprintf");
             return;
         }
 
         for (i = 0; i < me->level; i++) {
-            if (fwprintf(out, L"-") < 0) {
+            if (fish_fwprintf_impl(out, L"-") < 0) {
                 wperror(L"fwprintf");
                 return;
             }
         }
 
-        if (fwprintf(out, L"> %ls\n", me->cmd.c_str()) < 0) {
+        if (fish_fwprintf_impl(out, L"> %ls\n", me->cmd.c_str()) < 0) {
             wperror(L"fwprintf");
             return;
         }
@@ -305,7 +305,7 @@
     if (!f) {
         debug(1, _(L"Could not write profiling information to file '%s'"), path);
     } else {
-        if (fwprintf(f, _(L"Time\tSum\tCommand\n"), profile_items.size()) < 0) {
+        if (fish_fwprintf_impl(f, _(L"Time\tSum\tCommand\n"), profile_items.size()) < 0) {
             wperror(L"fwprintf");
         } else {
             print_profile(profile_items, f);
@@ -641,7 +641,7 @@
         this->get_backtrace(cmd, error_list, backtrace_and_desc);
 
         // Print it.
-        fwprintf(stderr, L"%ls\n", backtrace_and_desc.c_str());
+        fish_fwprintf_impl(stderr, L"%ls\n", backtrace_and_desc.c_str());
         return 1;
     }
     this->eval(ps, io, block_type);
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/parse_tree.cpp fish-3.0.2-workdir/src/parse_tree.cpp
--- fish-3.0.2-clean/src/parse_tree.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/parse_tree.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -407,17 +407,17 @@
         bool logit = false;
         if (logit) {
             int count = 0;
-            fwprintf(stderr, L"Applying production:\n");
+            fish_fwprintf_impl(stderr, L"Applying production:\n");
             for (int i = 0;; i++) {
                 production_element_t elem = production[i];
                 if (!production_element_is_valid(elem)) break;  // all done, bail out
                 parse_token_type_t type = production_element_type(elem);
                 parse_keyword_t keyword = production_element_keyword(elem);
-                fwprintf(stderr, L"\t%ls <%ls>\n", token_type_description(type),
+                fish_fwprintf_impl(stderr, L"\t%ls <%ls>\n", token_type_description(type),
                          keyword_description(keyword));
                 count++;
             }
-            if (!count) fwprintf(stderr, L"\t<empty>\n");
+            if (!count) fish_fwprintf_impl(stderr, L"\t<empty>\n");
         }
 
         // Get the parent index. But we can't get the parent parse node yet, since it may be made
@@ -524,9 +524,9 @@
         }
     }
 
-    fwprintf(stderr, L"Stack dump (%zu elements):\n", symbol_stack.size());
+    fish_fwprintf_impl(stderr, L"Stack dump (%zu elements):\n", symbol_stack.size());
     for (size_t idx = 0; idx < stack_lines.size(); idx++) {
-        fwprintf(stderr, L"    %ls\n", stack_lines.at(idx).c_str());
+        fish_fwprintf_impl(stderr, L"    %ls\n", stack_lines.at(idx).c_str());
     }
 }
 #endif
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/postfork.cpp fish-3.0.2-workdir/src/postfork.cpp
--- fish-3.0.2-clean/src/postfork.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/postfork.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -193,7 +193,7 @@
 
         switch (io->io_mode) {
             case IO_CLOSE: {
-                if (log_redirections) fwprintf(stderr, L"%d: close %d\n", getpid(), io->fd);
+                if (log_redirections) fish_fwprintf_impl(stderr, L"%d: close %d\n", getpid(), io->fd);
                 if (close(io->fd)) {
                     debug_safe_int(0, "Failed to close file descriptor %s", io->fd);
                     safe_perror("close");
@@ -232,7 +232,7 @@
             case IO_FD: {
                 int old_fd = static_cast<const io_fd_t *>(io)->old_fd;
                 if (log_redirections)
-                    fwprintf(stderr, L"%d: fd dup %d to %d\n", getpid(), old_fd, io->fd);
+                    fish_fwprintf_impl(stderr, L"%d: fd dup %d to %d\n", getpid(), old_fd, io->fd);
 
                 // This call will sometimes fail, but that is ok, this is just a precausion.
                 close(io->fd);
@@ -257,7 +257,7 @@
                       io->pipe_fd[1]);
 #endif
                 if (log_redirections)
-                    fwprintf(stderr, L"%d: %s dup %d to %d\n", getpid(),
+                    fish_fwprintf_impl(stderr, L"%d: %s dup %d to %d\n", getpid(),
                              io->io_mode == IO_BUFFER ? "buffer" : "pipe",
                              io_pipe->pipe_fd[write_pipe_idx], io->fd);
                 if (dup2(io_pipe->pipe_fd[write_pipe_idx], io->fd) != io->fd) {
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/proc.cpp fish-3.0.2-workdir/src/proc.cpp
--- fish-3.0.2-clean/src/proc.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/proc.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -605,11 +605,11 @@
     const wchar_t *msg = L"Job %d, '%ls' has ended";  // this is the most common status msg
     if (status == JOB_STOPPED) msg = L"Job %d, '%ls' has stopped";
 
-    fwprintf(stdout, L"\r");
-    fwprintf(stdout, _(msg), j->job_id, truncate_command(j->command()).c_str());
+    fish_fwprintf_impl(stdout, L"\r");
+    fish_fwprintf_impl(stdout, _(msg), j->job_id, truncate_command(j->command()).c_str());
     fflush(stdout);
     if (clr_eol) tputs(clr_eol, 1, &writeb);
-    fwprintf(stdout, L"\n");
+    fish_fwprintf_impl(stdout, L"\n");
 }
 
 void proc_fire_event(const wchar_t *msg, int type, pid_t pid, int status) {
@@ -699,7 +699,7 @@
                     // we don't need to.
                     const wcstring job_number_desc =
                         (job_count == 1) ? wcstring() : format_string(_(L"Job %d, "), j->job_id);
-                    fwprintf(stdout, _(L"%ls: %ls\'%ls\' terminated by signal %ls (%ls)"),
+                    fish_fwprintf_impl(stdout, _(L"%ls: %ls\'%ls\' terminated by signal %ls (%ls)"),
                              program_name, job_number_desc.c_str(),
                              truncate_command(j->command()).c_str(), sig2wcs(WTERMSIG(p->status)),
                              signal_get_desc(WTERMSIG(p->status)));
@@ -708,13 +708,13 @@
                         (job_count == 1) ? wcstring() : format_string(L"from job %d, ", j->job_id);
                     const wchar_t *fmt =
                         _(L"%ls: Process %d, \'%ls\' %ls\'%ls\' terminated by signal %ls (%ls)");
-                    fwprintf(stdout, fmt, program_name, p->pid, p->argv0(), job_number_desc.c_str(),
+                    fish_fwprintf_impl(stdout, fmt, program_name, p->pid, p->argv0(), job_number_desc.c_str(),
                              truncate_command(j->command()).c_str(), sig2wcs(WTERMSIG(p->status)),
                              signal_get_desc(WTERMSIG(p->status)));
                 }
 
                 if (clr_eol) tputs(clr_eol, 1, &writeb);
-                fwprintf(stdout, L"\n");
+                fish_fwprintf_impl(stdout, L"\n");
             }
             found = 1;
             p->status = 0;  // clear status so it is not reported more than once
@@ -792,7 +792,7 @@
         wchan, nswap, cnswap;
     char comm[1024];
 
-    swprintf(fn, FN_SIZE, L"/proc/%d/stat", p->pid);
+    fish_swprintf_impl(fn, FN_SIZE, L"/proc/%d/stat", p->pid);
     FILE *f = wfopen(fn, "r");
     if (!f) return 0;
 
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/reader.cpp fish-3.0.2-workdir/src/reader.cpp
--- fish-3.0.2-clean/src/reader.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/reader.cpp	2025-12-09 02:50:31.442834551 +1300
@@ -827,9 +827,9 @@
     proc_push_interactive(0);
     if (exec_subshell(fish_title_command, lst, false /* ignore exit status */) != -1 &&
         !lst.empty()) {
-        fputws(L"\x1B]0;", stdout);
+        fish_fputws_impl(L"\x1B]0;", stdout);
         for (size_t i = 0; i < lst.size(); i++) {
-            fputws(lst.at(i).c_str(), stdout);
+            fish_fputws_impl(lst.at(i).c_str(), stdout);
         }
         ignore_result(write(STDOUT_FILENO, "\a", 1));
     }
@@ -2007,7 +2007,7 @@
         secs -= 1;
     }
 
-    swprintf(buf, 16, L"%d", (secs * 1000) + (usecs / 1000));
+    fish_swprintf_impl(buf, 16, L"%d", (secs * 1000) + (usecs / 1000));
     env_set_one(ENV_CMD_DURATION, ENV_UNEXPORT, buf);
 }
 
@@ -2063,7 +2063,7 @@
         if (!string_suffixes_string(L"\n", error_desc)) {
             error_desc.push_back(L'\n');
         }
-        fwprintf(stderr, L"\n%ls", error_desc.c_str());
+        fish_fwprintf_impl(stderr, L"\n%ls", error_desc.c_str());
     }
     return res;
 }
@@ -2269,18 +2269,18 @@
 }
 
 void reader_bg_job_warning() {
-    fputws(_(L"There are still jobs active:\n"), stdout);
-    fputws(_(L"\n   PID  Command\n"), stdout);
+    fish_fputws_impl(_(L"There are still jobs active:\n"), stdout);
+    fish_fputws_impl(_(L"\n   PID  Command\n"), stdout);
 
     job_iterator_t jobs;
     while (job_t *j = jobs.next()) {
         if (!j->is_completed()) {
-            fwprintf(stdout, L"%6d  %ls\n", j->processes[0]->pid, j->command_wcstr());
+            fish_fwprintf_impl(stdout, L"%6d  %ls\n", j->processes[0]->pid, j->command_wcstr());
         }
     }
-    fputws(L"\n", stdout);
-    fputws(_(L"A second attempt to exit will terminate them.\n"), stdout);
-    fputws(_(L"Use 'disown PID' to remove jobs from the list without terminating them.\n"), stdout);
+    fish_fputws_impl(L"\n", stdout);
+    fish_fputws_impl(_(L"A second attempt to exit will terminate them.\n"), stdout);
+    fish_fputws_impl(_(L"Use 'disown PID' to remove jobs from the list without terminating them.\n"), stdout);
 }
 
 /// This function is called when the main loop notices that end_loop has been set while in
@@ -3464,7 +3464,7 @@
         } else {
             wcstring sb;
             parser.get_backtrace(str, errors, sb);
-            fwprintf(stderr, L"%ls", sb.c_str());
+            fish_fwprintf_impl(stderr, L"%ls", sb.c_str());
             res = 1;
         }
     } else {
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/wgetopt.cpp fish-3.0.2-workdir/src/wgetopt.cpp
--- fish-3.0.2-clean/src/wgetopt.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/wgetopt.cpp	2025-12-09 02:50:31.405833962 +1300
@@ -205,7 +205,7 @@
 
     if (temp == NULL || c == ':') {
         if (wopterr) {
-            fwprintf(stderr, _(L"%ls: Invalid option -- %lc\n"), argv[0], (wint_t)c);
+            fish_fwprintf_impl(stderr, _(L"%ls: Invalid option -- %lc\n"), argv[0], (wint_t)c);
         }
         woptopt = c;
 
@@ -236,7 +236,7 @@
         } else if (woptind == argc) {
             if (wopterr) {
                 // 1003.2 specifies the format of this message.
-                fwprintf(stderr, _(L"%ls: Option requires an argument -- %lc\n"), argv[0],
+                fish_fwprintf_impl(stderr, _(L"%ls: Option requires an argument -- %lc\n"), argv[0],
                          (wint_t)c);
             }
             woptopt = c;
@@ -263,11 +263,11 @@
         else {
             if (wopterr) {
                 if (argv[woptind - 1][1] == '-')  // --option
-                    fwprintf(stderr, _(L"%ls: Option '--%ls' doesn't allow an argument\n"), argv[0],
+                    fish_fwprintf_impl(stderr, _(L"%ls: Option '--%ls' doesn't allow an argument\n"), argv[0],
                              pfound->name);
                 else
                     // +option or -option
-                    fwprintf(stderr, _(L"%ls: Option '%lc%ls' doesn't allow an argument\n"),
+                    fish_fwprintf_impl(stderr, _(L"%ls: Option '%lc%ls' doesn't allow an argument\n"),
                              argv[0], argv[woptind - 1][0], pfound->name);
             }
             nextchar += wcslen(nextchar);
@@ -279,7 +279,7 @@
             woptarg = argv[woptind++];
         else {
             if (wopterr)
-                fwprintf(stderr, _(L"%ls: Option '%ls' requires an argument\n"), argv[0],
+                fish_fwprintf_impl(stderr, _(L"%ls: Option '%ls' requires an argument\n"), argv[0],
                          argv[woptind - 1]);
             nextchar += wcslen(nextchar);
             *retval = missing_arg_return_colon ? ':' : '?';
@@ -342,7 +342,7 @@
 
     if (ambig && !exact) {
         if (wopterr) {
-            fwprintf(stderr, _(L"%ls: Option '%ls' is ambiguous\n"), argv[0], argv[woptind]);
+            fish_fwprintf_impl(stderr, _(L"%ls: Option '%ls' is ambiguous\n"), argv[0], argv[woptind]);
         }
         nextchar += wcslen(nextchar);
         woptind++;
@@ -361,10 +361,10 @@
     if (!long_only || argv[woptind][1] == '-' || wcschr(shortopts, *nextchar) == NULL) {
         if (wopterr) {
             if (argv[woptind][1] == '-')  // --option
-                fwprintf(stderr, _(L"%ls: Unrecognized option '--%ls'\n"), argv[0], nextchar);
+                fish_fwprintf_impl(stderr, _(L"%ls: Unrecognized option '--%ls'\n"), argv[0], nextchar);
             else
                 // +option or -option
-                fwprintf(stderr, _(L"%ls: Unrecognized option '%lc%ls'\n"), argv[0],
+                fish_fwprintf_impl(stderr, _(L"%ls: Unrecognized option '%lc%ls'\n"), argv[0],
                          argv[woptind][0], nextchar);
         }
         nextchar = (wchar_t *)L"";
diff '--color=auto' -urN --no-dereference fish-3.0.2-clean/src/wutil.cpp fish-3.0.2-workdir/src/wutil.cpp
--- fish-3.0.2-clean/src/wutil.cpp	2019-02-20 02:39:17.000000000 +1300
+++ fish-3.0.2-workdir/src/wutil.cpp	2025-12-09 02:50:31.399753797 +1300
@@ -260,9 +260,9 @@
 void wperror(const wchar_t *s) {
     int e = errno;
     if (s[0] != L'\0') {
-        fwprintf(stderr, L"%ls: ", s);
+        fish_fwprintf_impl(stderr, L"%ls: ", s);
     }
-    fwprintf(stderr, L"%s\n", strerror(e));
+    fish_fwprintf_impl(stderr, L"%s\n", strerror(e));
 }
 
 int make_fd_nonblocking(int fd) {
@@ -319,7 +319,7 @@
 // have to grub through sys_nerr and sys_errlist directly On GNU toolchain, this will produce a
 // deprecation warning from the linker (!!), which appears impossible to suppress!
 const char *safe_strerror(int err) {
-#if defined(__UCLIBC__)
+#if defined(__UCLIBC__) || defined(__mlibc__)
     // uClibc does not have sys_errlist, however, its strerror is believed to be async-safe.
     // See issue #808.
     return strerror(err);
